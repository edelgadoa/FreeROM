///////////////
// FreeROM 
///////////////

// Programa que obtiene el valor del parametro en cada iteracion del GREEDY para EIM

// Definimos la matriz del sistema que resolveremos para calcular el EIM en cada iteracion
real [int,int] BMi(i,i);
BMi = BM(0:i-1,0:i-1);
real[int,int] Binv = BMi^-1; 
real [int] bEIM(i),sigmai(i);

pause; //Hacemos el siguiente for en paralelo
for (int imu=0; imu<nSnapshots; imu++){
	if (mpirank==imu%mpisize){
		gEIM = MOD(BV[imu]);
	
		for (int j=0; j<i; j++){
			beim(j) = gEIM[](Tmax(j));
		}
	
		sigmai = Binv*beim;
		
		for (int j=0;j<i;j++){
			IgEIM[] += sigmai(j)*BEIM[j][];
		}
		
		VhP1dc Linf=abs(gEIM-Ig); 
		
		ErroritL(eim)=Linf[].max/gEIM[].max;
	}
	mpiAllReduce(ErroritL, Errorit, mpiCommWorld, mpiSUM);
	pause;
	
	ErrorMaxEIM(i-1)=Errorit.max;
	muEIM(i)=vReynolds(Errs.imax);
	
}


// Calculamos la base escogida
gEIM = MOD(BV[vReynolds(Errorit.imax)]); // Tomo la base donde se encuentra el Reynolds con mayor error

for (int j=0; j<i; j++){
	beim(j) = gEIM[](Tmax(j));
}
sigmai = Binv*beim;

BEIM[i] = gEIM;
for int(j=0; j<i; j++){
	BEIM[i]-=sigma(j)*BEIM[j]; // Calculo los residuos
}

Tmax(i)=abs(BEIM[i]).imax;
BEIM[i]/=BEIM[i][](Tmax(i));

for (int j=0; j<i; j++){
	BM(i,j)=BEIM[j](Tmax(i));
}

// Almacenamos la base escogida 
ofstream BaseEIMFILE(/Bases_EIM/"Base_" + vReynolds(Errorit.imax) + ".txt");
BEIM>>BaseEIMFILE;

muEIM(i) = vReynolds(Errorit.imax); //Almacenamos el valor de Reynolds escogido	