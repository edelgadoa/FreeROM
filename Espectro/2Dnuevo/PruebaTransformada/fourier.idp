// Archivo auxiliar calculo de transformadas de fourier

// Cuando se calculen los coeficientes de la transformada de fourier, 
// la funci칩n debe llamarse uFourier y ser compleja.

// Si tengo varias componentes, debo llamar varias veces a FourierTransform2D, 
// redefiniendo uFourier.

func complex[int,int] FourierTransform2D(int kmax){

    complex[int,int] FCoefs(2*kmax+1,2*kmax+1);

    real[int] d;
    PartitionCreate(Th,d,Pk);
    Wh D;
    D[] = d;

    for(int ii=-kmax; ii<=kmax; ii++){
        for(int jj=-kmax; jj<=kmax; jj++){
            func fourier = exp(-1*1i*2*pi*(x*ii+y*jj));
            FCoefs(ii+kmax,jj+kmax) = int2d(Th)(D*fourier*uFourier);
        }
    }

    return FCoefs;
}

// Para calcular la funci칩n inversa hay que llamar una funci칩n auxiliar uFourier.
func complex[int] FourierInverse2D(complex[int,int] & Coefs){

    int kcoefs = (Coefs.n-1)/2;
    uFourier = 0;

    for(int ii = -kcoefs; ii<=kcoefs; ii++){
        for(int jj = -kcoefs; jj<=kcoefs; jj++){
            complex FCoef = Coefs(ii+kcoefs,jj+kcoefs);
            func BaseFourier = FCoef*exp(-1*1i*2*pi*(x*ii+y*jj));
            uFourier =  uFourier+BaseFourier;
        }
    }
    
    return uFourier[];
}

// C치lculo del espectro
func real[int,int] energycomputation(complex[int,int] & CoefsX, complex[int,int] & CoefsY)
{
    int kmax = (CoefsX.n-1)/2;
    real[int,int] resultL(2*kmax+1,2*kmax+1), result(2*kmax+1,2*kmax+1);
	resultL=0.; result=0.; 
	int cont = 1;
		
	for(int ii=-kmax;ii<=kmax;ii++){
		if(mpirank==cont%mpisize){
            for(int jj=-kmax; jj<=kmax; jj++){
                resultL(ii+kmax,jj+kmax)=(abs(CoefsX(ii+kmax,jj+kmax))^2+abs(CoefsY(ii+kmax,jj+kmax))^2)/2.;
            }
        }
	cont++;
	}
	mpiBarrier(mpiCommWorld);
	mpiAllReduce(resultL,result,mpiCommWorld,mpiSUM);
	return result;
}

/*
func real[int] energycomputation(complex[int] & u,complex[int] & uY, complex[int] & uZ)
{
	real[int] resultL(u.n), result(u.n);
	resultL=0.; result=0.; 
	int cont = 1;
	for(int ii=0;ii<result.n;ii++){
		if(mpirank==cont%mpisize){
			resultL[ii]=(uporu(u[ii])+uporu(uY[ii])+uporu(uZ[ii]))/2.;
		}
	cont++;
	}
	mpiBarrier(mpiCommWorld);
	mpiAllReduce(resultL,result,mpiCommWorld,mpiSUM);
	return result;
}
*/