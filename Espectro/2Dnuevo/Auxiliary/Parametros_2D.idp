///////////////
// FreeROM //
///////////////

// Parametros a usar durante la ejecucion del codigo

// Parametros para el paralelo

include "macro_ddm.idp";
Mat MatAVh2P2per;
int[int] mapVh2P2per;

Mat MatAVhP1per;
int[int] mapVhP1per;

Mat MatAVhP2per;
int[int] mapVhP2per;

Mat MatAVhP1dcper;
int[int] mapVhP1dcper;

// Creo las matrices Mat asociadas a la malla en Descomposicion de Dominios

int[int] myN2o;
macro ThLN2O() myN2o // EOM
macro ThLPeriodicity()labPeriodic//
buildDmesh(ThL);
macro Pk2P2() [P2,P2] , periodic=[[labPeriodic[0],y], [labPeriodic[1],y], [labPeriodic[2],x], [labPeriodic[3],x]]// EOM
macro PkP1() P1 , periodic=[[labPeriodic[0],y], [labPeriodic[1],y], [labPeriodic[2],x], [labPeriodic[3],x]]// EOM
macro PkP2() P2 , periodic=[[labPeriodic[0],y], [labPeriodic[1],y], [labPeriodic[2],x], [labPeriodic[3],x]]// EOM
macro PkP1dc() P1dc, periodic=[[labPeriodic[0],y], [labPeriodic[1],y], [labPeriodic[2],x], [labPeriodic[3],x]]//EOM

mapVh2P2per = restrict(Vh2P2perL,Vh2P2per,myN2o);
{
	macro def(i) [i, iY] //
	macro init(i) [i, i] // EOM
	createMat(ThL, MatAVh2P2per, Pk2P2); 
}

mapVhP1per = restrict(VhP1perL, VhP1per, myN2o);
{
	createMat(ThL, MatAVhP1per, PkP1);
}

mapVhP2per = restrict(VhP2perL, VhP2per, myN2o);
{
	createMat(ThL, MatAVhP2per, PkP2);
}

mapVhP2per = restrict(VhP1dcperL, VhP1dcper, myN2o);
{
	createMat(ThL, MatAVhP1dcper, PkP1dc);
}

string sparamsv = "-pc_type lu -pc_factor_mat_solver_type mumps";

// Parametros del modelo VMS-Smago
real CS=0.18; // Smago

// Parametros mu
real Reynolds;
real Remin = 1000;
real Remax = 16000;
real dtRe= 625;
real niRe=(Remax-Remin)/dtRe+1.;
real Refijo=(Remax+Remin)/2.;

// Parametros para el problema de EF
real epspen = 1e-8;
real dt=1./32*10;
real dtsave=dt;
real TF=30.;
real T0=15.;
real niT = (TF-T0)/dt;
real errEF=10.,epsEF=1.e-11,errBR=10.,epsBR=epsEF;

// Parametros para el espectro
real hTri=sqrt(2)/NN;
real k1=5,k2=NN/2;//256/2,
real kc=1./hTri;
real alpha = 5./3.;

// Parametros para el problema ROM
int niterRB = 2000;
real epsPOD = 1.e-10;
real epsEIM = 5.e-5;

// Parametros para el Greedy
int NiterGreddy = 1;
real epsGreedy = 5.e-5;
int Ntrain = niRe;
real[int] MuTrain(Ntrain);
for (int ig=0; ig<Ntrain; ig++){
	MuTrain(ig) = Remin+ig*(Remax-Remin)/(Ntrain - 1);
}
