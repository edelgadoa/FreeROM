///////////////
// FreeROM 
/////////////// 

// Código para construir EN PARALELO las matrices de base reducida

// TODO: Posibilidad de dividirlo en varios archivos, para cada tipo de matriz 

// Inicializo las matrices locales para el paralelo
include "Allocate_matrices_local.idp"

// Comienzo el bucle de construccion de las matrices reducidas fijas
int contFF = 0; // Contador para el paralelo
for (int j=0; j<=i; j++){
	if (mpirank==contFF%mpisize){
		// Matrices
		DiffRBL(i,j) = innerprodX(BaseV[i][], BaseV[j][], DiffPEM); 
		DivPRBL(i+Nbases, j) = innerprodX(BaseP[i][], BaseV[j][], DivPPEM);
		PenRBL(i+Nbases, j+Nbases) = innerprodX(BaseP[i][], BaseP[j][], PenPEM);
		DTRBL(i,j) = innerprodX(BaseV[i][], BaseV[j][], DTPEM);
		// StabhkRBL(i+Nbases, j+Nbases) = innerprodX(BaseP[i][], BaseP[j][],StabhkPEM);
		
		if (j<i){
			DiffRBL(j,i) = DiffRBL(i,j);
			DivPRBL(j+Nbases, i) = innerprodX(BaseP[j][], BaseV[i][], DivPPEM);
			PenRBL(j+Nbases, i+Nbases) = PenRBL(i+Nbases, j+Nbases);
			DTRBL(j,i) = DTRBL(i,j);
			// StabhkRBL(j+Nbases, i+Nbases) = StabhkRBL(i+Nbases, j+Nbases);
		}	
	}
	contFF++;
}
pause;

mpiAllReduce(DiffRBL, DiffRBG, mpiCommWorld, mpiSUM);
mpiAllReduce(DivPRBL, DivPRBG, mpiCommWorld, mpiSUM);
mpiAllReduce(PenRBL, PenRBG, mpiCommWorld, mpiSUM);
mpiAllReduce(DTRBL, DTRBG, mpiCommWorld, mpiSUM);
// mpiAllReduce(StabhkRBL, StabhkRBG, mpiCommWorld, mpiSUM);

DiffRB += DiffRBG;
DivPRB += DivPRBG;
PenRB += PenRBG;
DTRB += DTRBG;

// Comienzo el bucle para la construcción de los tensores

// Conveccion

for (int s=0; s<=i; s++){
	real[int, int] CintL(2*Nbases, 2*Nbases), CintG(2*Nbases, 2*Nbases);
	CintL = 0; CintG = 0;
	contFF = 0;
	for (int j=0; j<=i; j++){
		if (mpirank==contFF%mpisize){
			CintL(i,j) = innerprodX(BaseV[i][], BaseV[j][], ConvPEM[s]);
			if(j<i){
				CintL(j,i) = innerprodX(BaseV[j][], BaseV[i][], ConvPEM[s]);
			}
			if (s==i && (j!=i)){
				for (int k=0; k<s; k++){
					CintL(k,j) = innerprodX(BaseV[k][], BaseV[j][], ConvPEM[s]);
				}
			} 
		}
		contFF++;		
	}
	pause;
	mpiAllReduce(CintL, CintG, mpiCommWorld, mpiSUM);
	
	ConvRB[s] += CintG;
}

// Smagorinsky
for (int s=0; s<Mbases; s++){
	real[int, int] SintL(2*Nbases, 2*Nbases), SintG(2*Nbases, 2*Nbases);
	SintL = 0; SintG = 0;
	contFF = 0;
	for (int j=0; j<=i; j++){
		if (mpirank==contFF%mpisize){
			SintL(i,j) = int2d(Th)((CS*hTriangle)^2*EIMSmago[s]*gradugradv(FBaseV[j],FBaseVY[j],FBaseV[i],FBaseVY[i]));
			if(j<i){
				SintL(j,i) = SintL(i,j);
			}
		}
		contFF++;		
	}
	pause;
	mpiAllReduce(SintL, SintG, mpiCommWorld, mpiSUM);	
	SmagoRB[s] += SintG;
}


// Matrices para el EIM de Smago
for (int s=0; s<Mbases; s++){
   real[int,int] Dtk = GradPM[s];
   
   Dtk(0,i) = FVdX[i][](PuntosMSmago(s));
   Dtk(1,i) = FVdY[i][](PuntosMSmago(s));
   Dtk(2,i) = FVYdX[i][](PuntosMSmago(s));
   Dtk(3,i) = FVYdY[i][](PuntosMSmago(s));
   GradPM[s] = Dtk;
}
pause;

for (int s=0; s<Mbases; s++){
		bSmagoRB(s,i) = innerprodX(FBaseV[i][], FBaseV[i][], SmagoPEM[s]);
}