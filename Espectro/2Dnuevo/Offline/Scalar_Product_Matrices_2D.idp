///////////////
// FreeROM 
/////////////// 

// Defino las matrices de producto escalar T que voy a considerar para la ortonormalizacion

Mat prodV = MatAVh2P2per; 
{
	varf a([u,uY],[v,vY]) = int2d(ThL)((1./Refijo+MOD(uFijo))*gradugradv(u,uY,v,vY));
	// matrix prodVtemp = a(Vh2P2perL, Vh2P2perL);
	// Mat prodVT = prodVtemp;
	// prodV = prodVT;
	prodV = a(Vh2P2perL, Vh2P2perL);
}

Mat prodP;
{
	varf a(u,v) = int2d(ThL)(u*v);
	matrix prodPtemp = a(VhP1perL, VhP1perL);
	Mat prodPT = prodPtemp;
	prodP = prodPT;
}

// prodV y prodP están duplicados con MPescT, MPescX, MPescV. Decidir cuál nos quedamos #TODO

Mat MPescT, MPescX, MPescV;
{
	varf pescT ([uu, uuY], [v,vY]) = int2d(ThL)((1./Refijo + MOD(uFijo))*GradUGradV(uu,v));
	matrix pescTemp = pescT(Vh2P2perL, Vh2P2perL);
	Mat pescTT = pescTemp;
	MPescT = pescTT;


	varf pescX ([uu, uuY, uuP], [v,vY, vP]) = int2d(ThL)((1./Refijo + MOD(uFijo))*GradUGradV(uu,v) + uuP*vP);
	matrix pescXTemp = pescX(Vh3P2perL, Vh3P2perL);
	Mat pescXT = pescXTemp;
	MPescX = pescXT;

	varf NormaVel([uu,uuY],[vv,vvY]) = int2d(ThL)(GradUGradV(uu,vv));
	matrix MNormaVel = NormaVel(Vh2P2perL, Vh2P2perL);
	Mat MNormaVT = MNormaVel;
	MPescV = MNormaVT;
}
///////////////////////////////////////////////////////

Mat DiffPEM, DivPPEM, PenPEM, DTPEM;

{
	varf DiffPE([uu,uuY], [v,vY]) = int2d(ThL)(GradUGradV(uu,v));
	matrix DiffPEMT = DiffPE(Vh2P2perL,Vh2P2perL);
	Mat DiffPEMTemp = DiffPEMT;
	DiffPEM = DiffPEMTemp;

	varf DivPPE([uu,uuY], [vP]) = int2d(ThL)(Div(uu)*vP);
	matrix DivPPEMT = DivPPE(Vh2P2perL, VhP1perL);
	Mat DivPPEMTemp(MatAVhP1per, MatAVh2P2per, DivPPEMT);
	DivPPEM = DivPPEMTemp;

	varf PenPE(uP, vP) = int2d(ThL)(epspen*uP*vP);
	matrix PenPEMT = PenPE(VhP1perL, VhP1perL);
	Mat PenPEMTemp = PenPEMT;
	PenPEM = PenPEMTemp;

	varf DTPE([uu,uuY], [v,vY]) = int2d(ThL)(UporV(uu,v));
	matrix DTPEMT = DTPE(Vh2P2perL, Vh2P2perL);
	Mat DTPEMTemp = DTPEMT;
	DTPEM = DTPEMTemp;
}

Mat[int] ConvPEM(2*Nbases); // Simplemente inicializo, dentro del bucle del greedy definiré los prod. esc. segun vaya calculando las bases


Mat[int] SmagoPEM(Mbases);
{
	for (int s=0; s<Mbases; s++){
		// Matrices Smago
		varf SmagoPE([uu,uuY],[v,vY]) = int2d(ThL)((CS*hTriangle)^2*EIMSmago[s]*GradUGradV(uu,v));
		matrix SmagoL = SmagoPE(Vh2P2perL, Vh2P2perL);
		Mat SmagoTemp = SmagoL;
		SmagoPEM[s] = SmagoTemp;
	}
}