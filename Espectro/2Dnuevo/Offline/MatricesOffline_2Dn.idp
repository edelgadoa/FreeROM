///////////////
// FreeROM 
/////////////// 

// CÃ³digo para construir EN PARALELO las matrices de base reducida

// TODO: Posibilidad de dividirlo en varios archivos, para cada tipo de matriz 

// Inicializo las matrices locales para el paralelo
// include "Allocate_matrices_local.idp"

// Comienzo el bucle de construccion de las matrices reducidas fijas
for (int i=0; i<NbasesV; i++){
	real[int] BaseVi;
	ChangeNumbering(MatAVh2P2per, BaseV[i][], BaseVi);
    
	for (int j=0; j<=i; j++){
		real[int] BaseVj;
		ChangeNumbering(MatAVh2P2per, BaseV[j][], BaseVj);
        // Matrices
        DiffRB(i,j) = innerprodX(BaseVi, BaseVj, DiffPEM);
        DTRB(i,j) = innerprodX(BaseVi, BaseVj, DTPEM);
        if (j<i){
            DiffRB(j,i) = DiffRB(i,j);
            DTRB(j,i) = DTRB(i,j);	
        }
    }
    for (int j=0; j<NbasesP; j++){
		real[int] BasePj;
		ChangeNumbering(MatAVhP1per, BaseP[j][], BasePj);
    	DivPRB(j+2*Nbases, i) = innerprodX(BasePj, BaseVi, DivPPEM);
        
    }
}
for (int i=0; i<NbasesP; i++){
	real[int] BasePi;
	ChangeNumbering(MatAVhP1per, BaseP[i][], BasePi);
	
    for (int j=0; j<=i; j++){
		real[int] BasePj;
		ChangeNumbering(MatAVhP1per, BaseP[j][], BasePj);
		// Matrices
        PenRB(i+2*Nbases, j+2*Nbases) = innerprodX(BasePi, BasePj, PenPEM);
        if (j<i){
            PenRB(j+2*Nbases, i+2*Nbases) = PenRB(i+2*Nbases, j+2*Nbases);
        }   
    }
}

write("Output.txt","Matrices varias OK.",1,1);


// mpi(cout << DiffRB << endl;)
// mpi(cout << DivPRB << endl;)
// mpi(cout << PenRB << endl;)
// mpi(cout << DTRB << endl;)

// Conveccion
for (int s=0; s<NbasesV; s++){
    real[int, int] Cint(3*Nbases, 3*Nbases);
    Cint = ConvRB[s]; 
    for (int i=0; i<NbasesV; i++){
		real[int] BaseVi;
		ChangeNumbering(MatAVh2P2per, BaseV[i][], BaseVi);
        for (int j=0; j<=i; j++){
			real[int] BaseVj;
			ChangeNumbering(MatAVh2P2per, BaseV[j][], BaseVj);
            Cint(i,j) = innerprodX(BaseVi, BaseVj, ConvPEM[s]);
            if(j<i){
                Cint(j,i) = innerprodX(BaseVj, BaseVi, ConvPEM[s]);
            } 
            if (s==i && (j!=i)){
                for (int k=0; k<s; k++){
					real[int] BaseVk;
					ChangeNumbering(MatAVh2P2per, BaseV[k][], BaseVk);
                    Cint(k,j) = innerprodX(BaseVk, BaseVj, ConvPEM[s]);
                }
            } 
        }
    }

    ConvRB[s] = Cint;
}
write("Output.txt","Conveccion OK.",1,1);

// mpi(cout<<ConvRB[0]<<endl;) //Cambia el valor de la matriz segun el num de procesadores. Hay que ver si funciona despues.

// Smagorinsky
for (int s=0; s<Mbases; s++){
    real[int, int] Sint(3*Nbases, 3*Nbases);
    Sint = SmagoRB[s]; 
    for (int i=0; i<NbasesV; i++){
		real[int] BaseVi;
		ChangeNumbering(MatAVh2P2per, BaseV[i][], BaseVi); //Si se hace VMS hay que cambiarlo por FBaseV
        for (int j=0; j<=i; j++){
			real[int] BaseVj;
			ChangeNumbering(MatAVh2P2per, BaseV[j][], BaseVj);
            Sint(i,j) = innerprodX(BaseVi, BaseVj, SmagoPEM[s]); 
            if(j<i){
                Sint(j,i) = Sint(i,j);
            }	
        }
    }
    SmagoRB[s] += Sint;
}

// mpi(cout<<SmagoRB[0]<<endl;)
write("Output.txt","Smagorinsky OK.",1,1);


// Matrices para el EIM de Smago

for (int i=0; i<NbasesV; i++){	
	
	int MbasesL;
	for (int s=0; s<Mbases; s++){
		real[int,int] Dtk(GradPM[s].n, GradPM[s].m);
		real[int,int] DtkL = GradPM[s];

		Dtk = 0;

		if (NumberPMSmago(s)>0){
    		DtkL(0,i) = BVdX[i][](PuntosMSmagoL(MbasesL));  
    		DtkL(1,i) = BVdY[i][](PuntosMSmagoL(MbasesL));
    		DtkL(2,i) = BVYdX[i][](PuntosMSmagoL(MbasesL));
    		DtkL(3,i) = BVYdY[i][](PuntosMSmagoL(MbasesL));
			
		    DtkL *= WeightPMSmago(s);
		    MbasesL++;
		}
		mpiAllReduce(DtkL, Dtk, mpiCommWorld, mpiSUM);
		GradPM[s] = Dtk;
	}	
}

mpi(cout<<GradPM[0]<<endl;)


write("Output.txt","EIM Smagorinsky OK.",1,1);
