///////////////
// FreeROM 
/////////////// 

// Código para calcular las bases ortonormalizadas 

/////////////////////////////////////////////
// Ortonormalizacion de la Presion

real[int, int] MBasePi = MBaseP(0:VhP1perL.ndof-1, 0:i-1);

BaseP[i][] = OrtoL2(BaseP[i][], MBasePi);

// Doble Ortonormalización
BaseP[i][] = OrtoL2(BaseP[i][], MBasePi);

mpi(cout<<"Inicializacion matrices..." <<endl;)

////////////////////////////////////////////
real[int,int] MBaseVi = MBaseV(0:Vh2P2perL.ndof-1, 0:i-1);

BaseV[i][] = OrtoX(BaseV[i][], MBaseVi, MNormaVel);

mpi(cout<<"Inicializacion matrices..." <<endl;)

// Doble Ortonormalización
BaseV[i][] = OrtoX(BaseV[i][], MBaseVi, MNormaVel);

// Para el filtrado (Smago -> no necesario)
// BaseVel[i] = BaseV[i]; BaseVelY[i] = BaseVY[i];

///////////////////////////////////////////////////////////////////////////////
// func real[int] proy(real[int] & u,real[int] & v, matrix & X)
// {
// 	real[int] aux=X*u;
// 	real vu=v'*aux;
// 	real uu=u'*aux;
// 	real[int] result=u;
// 	result*=vu/uu;
// 	return result;
// }
//
//
// func real innerprod(real[int] & u,real[int] & v,matrix & A){real[int] aux=A*v;real result=u'*aux;return result;}
// func real normL2(real[int] & u, matrix & A){real result=innerprod(u,u,A);return sqrt(result);}
//
// macro ortho(base,NN,prod)
// {real[int] proyection(base[0][].n);
// proyection=0;
// for(int ii=0;ii<NN-1;ii++)proyection+=proy(base[ii][],base[NN-1][],prod);
// base[NN-1][]-=proyection;}
// //EOM
//
// macro normalization(base,nbasis,X)
// {for(int ii=0; ii<nbasis;ii++)base[ii][]/=normL2(base[ii][],X);}//EOM