///////////////
// FreeROM 
/////////////// 

// Código para calcular las bases ortonormalizadas 

//Redimensionamos con el numero de bases obtenidas en la POD
MBaseV.resize(MBaseV.n, NbasesV);
MBaseP.resize(MBaseP.n, NbasesP);



/////////////////////////////////////////////
// Ortonormalizacion de la Presion

for (int i=0; i<NbasesP; i++){
	real[int, int] MBasePi = MBaseP(0:VhP1perL.ndof-1, 0:i-1);
	
	BaseP[i][] = OrtoL2(BaseP[i][], MBasePi);

	// Doble Ortonormalización (de momento hacemos una unica ortonormalizacion)
	// BasePi = OrtoX(BasePi, MBasePi, prodP); 
}

mpi(cout<<"Presion ortonormalizada..." <<endl;)

/// ///////////////////////////////////////////
//
for (int i=0; i<NbasesV; i++){
	real[int,int] MBaseVi = MBaseV(0:Vh2P2perL.ndof-1, 0:i-1);
	real[int] BaseVi;
	ChangeNumbering(MatAVh2P2per, BaseV[i][], BaseVi);

	BaseVi = OrtoX(BaseVi, MBaseVi, prodV);

// Doble Ortonormalización
// BaseV[i][] = OrtoX(BaseV[i][], MBaseVi, MPescV);
}
mpi(cout<<"Velocidad ortonormalizada..." <<endl;)


// Para el filtrado (Smago -> no necesario)
// BaseVel[i] = BaseV[i]; BaseVelY[i] = BaseVY[i];

///////////////////////////////////////////////////////////////////////////////
// func real[int] proy(real[int] & u,real[int] & v, matrix & X)
// {
// 	real[int] aux=X*u;
// 	real vu=v'*aux;
// 	real uu=u'*aux;
// 	real[int] result=u;
// 	result*=vu/uu;
// 	return result;
// }
//
//
// func real innerprod(real[int] & u,real[int] & v,matrix & A){real[int] aux=A*v;real result=u'*aux;return result;}
// func real normL2(real[int] & u, matrix & A){real result=innerprod(u,u,A);return sqrt(result);}
//
// macro ortho(base,NN,prod)
// {real[int] proyection(base[0][].n);
// proyection=0;
// for(int ii=0;ii<NN-1;ii++)proyection+=proy(base[ii][],base[NN-1][],prod);
// base[NN-1][]-=proyection;}
// //EOM
//
// macro normalization(base,nbasis,X)
// {for(int ii=0; ii<nbasis;ii++)base[ii][]/=normL2(base[ii][],X);}//EOM