///////////////
// FreeROM 
/////////////// 

/////////////////////////////////////////
/////////// FASE OFFLINE ////////////////
//// NS + VMS-Smago + Estab Pres (LPS)///
/////////////////////////////////////////
/////////// NO SUPREMIZER ///////////////
/////////////////////////////////////////

// Codigo para calcular la fase offline VMS-Smago con estabilizacion LPS en la presion. 
// Elemento Finito P2-P2 (no estable) en vel-pres SIN SUPREMIZER

// Cargamos librerias
load "iovtk" 
load "lapack"

// Cargamos macros, funciones i/o
include "../Auxiliary/Macros_2D.idp"
include "../Auxiliary/search.idp"
include "../Auxiliary/IO.idp"

// Creamos la Malla
include "../Auxiliary/Malla.idp"

// Definimos los espacios de EF
include "../FOM/FE_Spaces_NoStab_VP_2D.idp"

// Definimos las matrices de interpolacion y derivacion
include "../FOM/Interp_matrix_NoStab_VP_2D.idp"

// Definimos los parametros a usar
include "../Auxiliary/Parametros_2D.idp"

// Defino funciones para ortonormalizar y productos escalares / normas
include "../Auxiliary/Normas.idp"

//Definicion de Constantes y variables varias
int Nbases = NiterGreddy*niT; 

real[int] MuBest(Nbases+1), DeltaN(Nbases), TauN(Nbases), ErrorVN(Nbases), ErrorPN(Nbases);

// Leo los valores de los parámetros para los cuales he calculado ya Snapshots
readvector("../Snapshots/Snapshots.txt", real, ReSnapshots, 0);

//////////////////////////////////////////
////DEFINICION DE LOS ESPACIOS DE BR//////
//////////////////////////////////////////
mpi(cout<<"Inicializacion espacios BR..." <<endl;)

Vh2P2per[int] [BaseV,BaseVY](Nbases);
VhP1per[int] BaseP(Nbases);
VhP2per[int] BaseVel(Nbases);
VhP2per[int] BaseVelY(Nbases);

Vh2P2per[int] [FBaseV, FBaseVY](Nbases);//, FBaseVY(Nbases);

VhP2per[int] FBaseVel(Nbases), FBaseVelY(Nbases);;

VhP1dcper[int] FPdX(Nbases), FPdY(Nbases);

VhP1dcper[int] FVdX(Nbases), FVdY(Nbases);
VhP1dcper[int] FVYdX(Nbases),FVYdY(Nbases);

// Defino las matrices donde almaceno los snapshots por columnas, para la reconstruccion de la solucion reducida
int NbasesV=1; int NbasesP=1;
real[int, int] MBaseV(Vh2P2per.ndof, 1), MBaseP(VhP1per.ndof, 1);
Reynolds = Refijo;
MuBest(0) = Reynolds;
readvector("../Snapshots/Vx_" + Reynolds + "_t_" +T0+ ".txt", real, SolX, 0);
readvector("../Snapshots/Vy_" + Reynolds + "_t_" +T0+ ".txt", real, SolY, 0);
readvector("../Snapshots/P_" + Reynolds + "_t_" +T0+ ".txt", real, SolP, 0);

Vh3P2per [VVx,VVy,PP]; //Hay que cargarlos en Vh3P2per y despues pasarlos a Vh2P2per+VhP1per
VVx[] = SolX; VVy[] = SolY; PP[] = SolP;

Vh2P2per [Vx,Vy]; VhP1per PPP;
[Vx,Vy] = [VVx,VVy]; PPP = PP;

// Inicializacion de las matrices de reducido, de esta forma la CI solo se incluye una vez
MBaseV(:,0) = Vx[];
MBaseP(:,0) = PPP[];
 
/////////////////////////////////////////
mpi(cout<<"Inicializacion EIM..." <<endl;)
// Cargo los elementos del EIM
include "EIM_Data.idp"

// Inicializo las matrices para la fase offline
mpi(cout<<"Inicializacion matrices..." <<endl;)
include "Allocate_matrices_2D.idp"

/////////////////////////////////////////
// Comenzamos con el Algoritmo Greedy
mpi(cout<<"Inicializacion Greedy..." <<endl;)

Reynolds = Remin; // Inicializamos el Reynolds, y todas las variables para resolver el problema de EF
MuBest(0) = Reynolds;

VhP2per uFijo, uFijoY; //Para la normaT
VhP1dcper uFijodX, uFijodY, uFijoYdX, uFijoYdY;

Vh3P2per [uEF, uEFY, uEFP]; // Serán las soluciones para el Re_fijo
VhP1dcper uEFdX, uEFdY, uEFYdX, uEFYdY; //las derivadas de uEF del paso anterior 
VhP2per uprev, uprevY;
VhP1dcper Gr; // Para el termino de VMS-Smagorinsky


// Defino los diferentes productos escalares para construir las matrices reducidas
include "Scalar_Product_Matrices_2D.idp"

for (int i=0; i<NiterGreddy; i++){
	
	mpi(cout<<"---Iteracion " + (i+1) + " for Re=" + Reynolds <<endl;)
	if (search(ReSnapshots, Reynolds, 1.e-9)==-1){
		// Si no lo he calculado todavía, lo calculo

		include "../FOM/FE_VMS_2D.idp"	
		
		// Actualizamos el vector de parametros calculados
		ReSnapshots.resize(ReSnapshots.n+1);
		ReSnapshots(ReSnapshots.n-1) = Reynolds;
		write("../Snapshots/Snapshots.txt", ReSnapshots, 0, 0);
	}

	// Cargamos todos los snapshots en tiempo
	MBaseV.resize(MBaseV.n,NbasesV+niT);
	MBaseP.resize(MBaseP.n,NbasesP+niT);
	for(int i=0; i<niT; i++){
		real tt = T0+(i+1)*dt;
		Vh3P2per [uaux, uauxY, uauxP];
		readvector("../Snapshots/Vx_" + Reynolds + "_t_" +tt+ ".txt", real, SolX, 0);
		readvector("../Snapshots/Vy_" + Reynolds + "_t_" +tt+ ".txt", real, SolY, 0);
		readvector("../Snapshots/P_" + Reynolds + "_t_" +tt+ ".txt", real, SolP, 0);
		uaux[] = SolX; uauxY[] = SolY; uauxP[] = SolP;
		Vh2P2per [Vx,Vy]; VhP1per PPP;
		[Vx,Vy] = [uaux,uauxY]; PPP = uauxP;
		MBaseV(:,NbasesV+i) = Vx[];
		MBaseP(:,NbasesP+i) = PPP[];
	}
	// Calculamos la POD
	write("Output.txt","Computing the complete basis...",1,1);
	{
		include "POD.idp"
		POD(MBaseV,prodV,BaseV,NbasesV,autovalVel);
		POD(MBaseP,prodP,BaseP,NbasesP,autovalPres);
	}
	write("Output.txt","At the end, for vel "+NbasesV+" basis and for pres "+NbasesP+" basis.",1,1);

	// Calculamos el supremizer
	write("Output.txt","Supremizer construction...",1,1);
	for(int i=0;i<NbasesP;i++)
	{
		Vh2P2per [supEF,supEFY];
		include "supremizer.idp"
		supremizer(BaseP[i],Reynolds,supEF);
		BaseV[NbasesV+i][]=supEF[];
	}
	NbasesV += NbasesP; 
	write("Output.txt","Ok.",1,1);

	// Hacemos la ortonormalizacion
	write("Output.txt","Orthonormalization...",1,1);

	for(int i=0;i<NbasesV;i++){
		BaseVel[i] = BaseV[i]; BaseVelY[i] = BaseVY[i];
	}
	include "GramSchmidt_2D.idp"
	
	ortho(BaseV,NbasesV,prodV);
	ortho(BaseV,NbasesV,prodV); // Doble ortonormalizacion
	ortho(BaseP,NbasesP,prodP);
	ortho(BaseP,NbasesP,prodP); // Doble ortonormalizacion
	
	write("Output.txt","Ok.",1,1);
	
	// Almaceno en las matrices las Bases ortonormalizadas por columnas
	for(int i=0;i<NbasesP;i++){
		MBaseP(:,i) = BaseP[i][];
	}
	for(int i=0;i<NbasesV;i++){
		MBaseV(:,i) = BaseV[i][];
		BaseVel[i] = BaseV[i]; BaseVelY[i] = BaseVY[i];
	
		// Actualizo las soluciones filtradas
		FBaseV[i][] = IPh2P22P1 * BaseV[i][];
		
		FBaseVel[i][] = IPhP2P1*BaseVel[i][]; FBaseVelY[i][] = IPhP2P1*BaseVelY[i][]; 
		
		FVdX[i][] = DXP2*FBaseVel[i][]; FVdY[i][] = DYP2*FBaseVel[i][];
		FVYdX[i][] = DXP2*FBaseVelY[i][]; FVYdY[i][] = DYP2*FBaseVelY[i][];
		
		// Defino el nuevo producto escalar para la convección
		varf ConvPE([uu,uuY], [v,vY]) = int2d(Th)(antisimetric(BaseV[i],BaseVY[i],uu,uuY,v,vY));
		ConvPEM[i] = ConvPE(Vh2P2per, Vh2P2per);
	}
	
	// ** HASTA AQUI ESTA BIEN

	// Construyo las matrices
	write("Output.txt","Building offline matrices...",1,1);
	include "MatricesOffline_2Dn.idp"
	write("Output.txt","Ok.",1,1);

	// Hago el algoritmo Greedy para determinar el nuevo valor del parámetro
	write("Output.txt","Solving Reduced problem...",1,1);
	include "Greedy_2D.idp"
	
	/*
	// Actualizo el nuevo Reynolds
	Reynolds = MuBest(i+1);
	mpi(cout<<"New Reynolds: "<<Reynolds<<endl;)
	
	mpi(cout<<"-------FIN DE LA ITERACION "<<i<<"-------"<<endl;)
	
	if (DeltaN(i)<epsGreedy){
		NRB = i + 1;
		include "Save_Matrices.idp"
		break;
	}
	*/
}