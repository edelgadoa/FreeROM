///////////////
// FreeROM 
/////////////// 

//////////////////////////////////////////////////
/////////// FASE OFFLINE /////////////////////////
//// Unsteady NS + Smago + BC periodicas /////////
//////////////////////////////////////////////////

verbosity = 0;

// Codigo para calcular la fase offline VMS-Smago con estabilizacion LPS en la presion. 
// Elemento Finito P2-P2 (no estable) en vel-pres SIN SUPREMIZER

// Cargamos librerias
load "iovtk" 
load "lapack"


// Cargamos macros, funciones i/o
include "../Auxiliary/Macros_2D.idp"
include "../Auxiliary/search.idp"
include "../Auxiliary/IO.idp"
include "../Auxiliary/fourier.idp"
include "../Auxiliary/Functions_MP.idp"
include "macro_ddm.idp"

// Creamos la Malla
include "../Auxiliary/Malla.idp"

// Definimos los parametros a usar
include "../Auxiliary/Parametros_2D.idp"

// Definimos los espacios de EF
include "../FOM/FE_Spaces_NoStab_VP_2D.idp"



// Definimos las matrices de interpolacion y derivacion
include "../FOM/Interp_matrix_NoStab_VP_2D.idp"
include "../FOM/Interp_matrix_NoStab_VP_2D_Local.idp"

// Defino funciones para ortonormalizar y productos escalares / normas
include "../Auxiliary/Normas.idp"

//Definicion de Constantes y variables varias
int Nbases = NiterGreddy*niT; 

real[int] MuBest(NiterGreddy+1), DeltaN(NiterGreddy), TauN(NiterGreddy), ErrorVN(NiterGreddy), ErrorPN(NiterGreddy);

// Leo los valores de los parámetros para los cuales he calculado ya Snapshots
readvector("../Snapshots/Snapshots.txt", real, ReSnapshots, 0);

//////////////////////////////////////////
////DEFINICION DE LOS ESPACIOS DE BR//////
//////////////////////////////////////////
mpi(cout<<"Inicializacion espacios BR..." <<endl;)

mapVh2P2per = restrict(Vh2P2perL,Vh2P2per,myN2o);
{
    macro def(i) [i, iY] //
    macro init(i) [i, i] // EOM
    createMat(ThL, MatAVh2P2per, Pk2P2);
}

mapVhP1per = restrict(VhP1perL, VhP1per, myN2o);
{
    createMat(ThL, MatAVhP1per, PkP1);
}

mapVhP2per = restrict(VhP2perL, VhP2per, myN2o);
{
    createMat(ThL, MatAVhP2per, PkP2);
}

mapVhP1dcper = restrict(VhP1dcperL, VhP1dcper, myN2o);
{
    createMat(ThL, MatAVhP1dcper, PkP1dc);
}

Vh2P2perL[int] [BaseV,BaseVY](2*Nbases);
VhP1perL[int] BaseP(Nbases);
VhP2perL[int] BaseVel(2*Nbases);
VhP2perL[int] BaseVelY(2*Nbases);

// Si hacemos Smagorinsky (sin VMS), esto no es necesario. 
//Vh2P2perL[int] [FBaseV, FBaseVY](2*Nbases);//, FBaseVY(Nbases);

//VhP2perL[int] FBaseVel(2*Nbases), FBaseVelY(2*Nbases);;

VhP1dcperL[int] BVdX(2*Nbases), BVdY(2*Nbases);
VhP1dcperL[int] BVYdX(2*Nbases),BVYdY(2*Nbases);

// Defino las matrices donde almaceno los snapshots por columnas, para la reconstruccion de la solucion reducida
int NbasesV=1; 
int NbasesP=1;

real[int, int] MBaseV(Vh2P2perL.ndof, 1), MBaseP(VhP1perL.ndof, 1);
Reynolds = Refijo;
MuBest(0) = Reynolds;
readvector("../Snapshots/Vx_" + Reynolds + "_t_" + T0 + ".txt", real, SolX, 0);
readvector("../Snapshots/Vy_" + Reynolds + "_t_" + T0 + ".txt", real, SolY, 0);
readvector("../Snapshots/P_" + Reynolds + "_t_" + T0 + ".txt", real, SolP, 0);

// Cargamos los Snapshots en local
Vh3P2per [SnapXa,SnapYa,SnapPa];
SnapXa[] = SolX; SnapYa[] = SolY; SnapPa[] = SolP;

VhP2per SnapX, SnapY; 
VhP1per SnapP;  
SnapX = SnapXa; SnapY = SnapYa; SnapP = SnapPa;


VhP2perL SnapXL, SnapYL;
VhP1perL SnapPL;
SnapXL[] = SnapX[](mapVhP2per); SnapYL[] = SnapY[](mapVhP2per);
SnapPL[] = SnapP[](mapVhP1per);

Vh2P2perL [VelXL, VelYL] = [SnapXL, SnapYL]; 
//macro Pk2P2() [P2,P2] , periodic=[[labPeriodic[0],y], [labPeriodic[1],y], [labPeriodic[2],x], [labPeriodic[3],x]]// EOM



// Inicializacion de las matrices de reducido, de esta forma la CI solo se incluye una vez
MBaseV(:,0) = VelXL[];
MBaseP(:,0) = SnapPL[];
 
/////////////////////////////////////////
mpi(cout<<"Inicializacion EIM..." <<endl;)
// Cargo los elementos del EIM
include "EIM_Data.idp"

/////////////////////////////////////////
// Comenzamos con el Algoritmo Greedy
mpi(cout<<"Inicializacion Greedy..." <<endl;)

Reynolds = Remin; // Inicializamos el Reynolds, y todas las variables para resolver el problema de EF
MuBest(0) = Reynolds;

/// Esto hay que mirarlo, en principio iría en LOCAL tambien (como no resolvemos el FOM, no hace falta ahora)
VhP2per uFijo, uFijoY; //Para la normaT
uFijo = SnapX; uFijoY = SnapY; 
VhP1dcper uFijodX, uFijodY, uFijoYdX, uFijoYdY;
uFijodX[] = DXP2*uFijo[]; uFijodY[] = DYP2*uFijo[];
uFijoYdX[] = DXP2*uFijoY[]; uFijoYdY[] = DYP2*uFijoY[];

Vh3P2per [uEF, uEFY, uEFP]; // Serán las soluciones para el Re_fijo
VhP1dcper uEFdX, uEFdY, uEFYdX, uEFYdY; //las derivadas de uEF del paso anterior 
VhP2per uprev, uprevY;
VhP1dcper Gr; // Para el termino de VMS-Smagorinsky

// Defino los diferentes productos escalares para construir las matrices reducidas
include "Scalar_Product_Matrices_2D.idp"

for (int iGreedy=0; iGreedy<NiterGreddy; iGreedy++){
	
	mpi(cout<<"---Iteracion " + (iGreedy+1) + " for Re=" + Reynolds <<endl;)
	if (search(ReSnapshots, Reynolds, 1.e-9)==-1){

		// Si no lo he calculado todavía, lo calculo
		include "../FOM/FE_VMS_2D.idp"	
		
		// Actualizamos el vector de parametros calculados
		ReSnapshots.resize(ReSnapshots.n+1);
		ReSnapshots(ReSnapshots.n-1) = Reynolds;
		write("../Snapshots/Snapshots.txt", ReSnapshots, 0, 0);
	}

	// Cargamos todos los snapshots en tiempo
	NbasesV -= NbasesP;
	if (iGreedy == 0)NbasesV=1;
	
	MBaseV.resize(MBaseV.n, NbasesV + niT);
	MBaseP.resize(MBaseP.n, NbasesP + niT);
	for(int i=0; i<niT; i++){
		real tt = T0 + (i+1)*dt;
		Vh3P2per [SnapXa,SnapYa,SnapPa];
		VhP2per SnapX, SnapY;
		VhP1per SnapP;
		
		readvector("../Snapshots/Vx_" + Reynolds + "_t_" +tt+ ".txt", real, SolX, 0);
		readvector("../Snapshots/Vy_" + Reynolds + "_t_" +tt+ ".txt", real, SolY, 0);
		readvector("../Snapshots/P_" + Reynolds + "_t_" +tt+ ".txt", real, SolP, 0);

		SnapXa[] = SolX; SnapYa[] = SolY; SnapPa[] = SolP;
		SnapX = SnapXa; SnapY = SnapYa; SnapP = SnapPa;
		
		VhP2perL SnapXL, SnapYL; VhP1perL SnapPL;
		SnapXL[] = SnapX[](mapVhP2per); SnapYL[] = SnapY[](mapVhP2per);
		SnapPL[] = SnapP[](mapVhP1per);
		
		Vh2P2perL [VelXL, VelYL] = [SnapXL, SnapYL];

		MBaseV(:, NbasesV+i) = VelXL[];
		MBaseP(:, NbasesP+i) = SnapPL[];
	}

	// Calculamos la POD
	write("Output.txt","Computing the complete basis...",1,1);
	{
		include "POD.idp" // Hay que hacerla en paralelo, para que todo vaya bien (TODO)
		POD(MBaseV,MPescV,BaseV,NbasesV,autovalVel);
		POD(MBaseP,MPescP,BaseP,NbasesP,autovalPres);
	}
	write("Output.txt","After POD, for vel "+NbasesV+" basis and for pres "+NbasesP+" basis.",1,1);

	// Calculamos el supremizer
	write("Output.txt","Supremizer construction...",1,1);
	for(int i=0; i<NbasesP; i++){
		
		Vh2P2perL [supEF, supEFY];
		{include "Supremizer.idp"} //El calculo del supremizer esta en paralelo (TODO: comprobar que funciona)
		// supremizer(BaseP[i],Reynolds,supEF);
		BaseV[NbasesV+i][] = supEF[];
	}
	NbasesV += NbasesP; 
	
	//Me quedo solo con el numero de bases calculadas, y lo paso a real[int,int] con la numeracion PETSc
	Vh2P2perL[int] [BasePODV, BasePODVY](NbasesV);
	VhP1perL[int] BasePODP(NbasesP);
	
	// Inicializo las matrices para la fase offline
	mpi(cout<<"Inicializacion matrices..." <<endl;)
	include "Allocate_matrices_2D.idp"
	
	write("Output.txt","After supremizer, a total of "+(NbasesV+NbasesP)+" basis.",1,1);
	write("Output.txt","Ok.",1,1);

	// Hacemos la ortonormalizacion
	write("Output.txt","Orthonormalization...",1,1);

	// for(int i=0;i<NbasesV;i++)BaseVel[i] = BaseV[i]; BaseVelY[i] = BaseVY[i];
	//pause;
	// HASTA AQUÍ COMPILA BIEN
	
	//cout << BaseV[1][].n << endl;
	//real[int] BaseV1;
	//ChangeNumbering(MatAVh2P2per, BaseV[1][], BaseV1);
	//cout << BaseV1.n << endl;
	
	for (int i=0; i<NbasesV; i++){
		BasePODV[i][] = BaseV[i][];
	}
 
	for (int i=0; i<NbasesP; i++){
		BasePODP[i][] = BaseP[i][];
		VhP1per BasePG;
		reduceSolution(BasePODP[i], BasePG, MatAVhP1per.D, mapVhP1per);
		write
		plot(BasePG);
	}
    plotMPI(ThL, BaseP[0], PkP1, def, real, cmm="Base 0");
	
	real[int,int] MBasePODV(MatAVh2P2per.n, NbasesV), MBasePODP(MatAVhP1per.n, NbasesP);
	ChangeNumbering(MatAVh2P2per, BasePODV, MBasePODV);
	ChangeNumbering(MatAVhP1per, BasePODP, MBasePODP);
	

	// include "GramSchmidt_2D.idp"
	
	// Actualizo las matrices MBasePOD 
	//ChangeNumbering(MatAVh2P2per, BasePODV, MBasePODV);
	//ChangeNumbering(MatAVhP1per, BasePODP, MBasePODP);
	
	for (int i=0; i<NbasesV; i++){
		BaseV[i][] = BasePODV[i][];
	}

	for (int i=0; i<NbasesP; i++){
		BaseP[i][] = BasePODP[i][];
	}
	
	mpi(cout<<"Bases almacenadas"<<endl;)
	// ortho(BaseV,NbasesV,prodV);
	// normalization(BaseV,NbasesV,prodV);
	// ortho(BaseV,NbasesV,prodV); // Doble ortonormalizacion
	// ortho(BaseP,NbasesP,prodP);
	// normalization(BaseP,NbasesP,prodP);
	// ortho(BaseP,NbasesP,prodP); // Doble ortonormalizacion
	// write("Output.txt","Ok.",1,1);

	// Almaceno en las matrices las Bases ortonormalizadas por columnas
	
	for(int i=0;i<NbasesP;i++){
		MBaseP(:,i) = BaseP[i][];
	}
	mpi(cout<<"Matriz de conveccion"<<endl;)
	
	for(int i=0;i<NbasesV;i++){
		mpi(cout<<i<<endl;)
		MBaseV(:,i) = BaseV[i][];
		// Defino el nuevo producto escalar para la convección
		varf ConvPE([uu,uuY], [v,vY]) = int2d(ThL)(antisimetric(BaseV[i],BaseVY[i],uu,uuY,v,vY));
		Mat ConvPEMi = MatAVh2P2per;
		ConvPEMi = ConvPE(Vh2P2perL, Vh2P2perL);
		ConvPEM[i] = ConvPEMi;
		
		BaseVel[i] = BaseV[i]; BaseVelY[i] = BaseVY[i];
		
		BVdX[i][] = DXP2L*BaseVel[i][]; BVdY[i][] = DYP2L*BaseVel[i][];
		BVYdX[i][] = DXP2L*BaseVelY[i][]; BVYdY[i][] = DYP2L*BaseVelY[i][];
		
	}
		
	
	//
	// 	// Actualizo las soluciones filtradas (Si hacemos Smagorinsky solo, esto no es necesario)
	// 	// FBaseV[i][] = IPh2P22P1 * BaseV[i][];
	// 	//
	// 	// FBaseVel[i][] = IPhP2P1*BaseVel[i][]; FBaseVelY[i][] = IPhP2P1*BaseVelY[i][];
	// 	//
	
	// Construyo las matrices
	write("Output.txt","Building offline matrices...",1,1);
	include "MatricesOffline_2Dn.idp"
	write("Output.txt","Ok.",1,1);

	// Hago el algoritmo Greedy para determinar el nuevo valor del parámetro
	write("Output.txt","Solving Reduced problem...",1,1);
	include "Greedy_2D.idp"
	
	// Actualizo el nuevo Reynolds
	Reynolds = MuBest(iGreedy+1);
	mpi(cout<<"New Reynolds: "<<Reynolds<<endl;)
	
	mpi(cout<<"-------FIN DE LA ITERACION "<<iGreedy<<"-------"<<endl;)
	
	
	if (DeltaN(iGreedy)<epsGreedy){
		int NRB = NbasesV+NbasesP + 1;
		include "Save_Matrices.idp"
		break;
	}
	
}