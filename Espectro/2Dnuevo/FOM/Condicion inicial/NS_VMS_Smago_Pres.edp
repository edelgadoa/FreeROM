///////////////
// FreeROM 
///////////////

/////////////////////////////////////////
//// NS + VMS-Smago + Estab Pres (LPS)///
/////////////////////////////////////////

// Codigo para resolver el problema de EF de VMS-Smago. 
// Elemento Finito P2-P2 (no estable) en vel-pres 

// Cargamos librerias
load "iovtk" 

// Cargamos macros
include "../../Auxiliary/IO.idp"
include "../../Auxiliary/Macros_2D.idp"
include "../../Auxiliary/macro_ddm.idp"

// Creamos la malla
// include "../../Auxiliary/CuadradoNxNy.idp"

int NN = 32;
mesh Th=square(NN,NN,flags=0);


// Definimos los espacios de EF 
include "FE_Spaces_NoStab_VP_2D.idp"

// Definimos las matrices de interpolacion y derivacion
include "Interp_matrix_NoStab_VP_2D.idp"

// Definimos los parametros a usar
include "../../Auxiliary/Parametros_2D.idp"

/////////////////////////////////////////////
/// Establecemos la CI para EF: Cavidad 2D///
/////////////////////////////////////////////

// Cargamos el modulo para hacer transformadas
include "../../Auxiliary/fourier.idp"

VhP1 <complex> ZZ,zz;

// Creamos el espectro artificialmente
real module;
for(int k=-NN/2;k<=NN/2;k++)
{
	for(int l=-NN/2;l<=NN/2;l++)
	{
		module=sqrt(k^2+l^2);
		if(sqrt(module)<1-1.e-3)
		{
			ZZ[][(k+NN/2)+(NN+1)*(l+NN/2)]=0.;
		}
		else
		{
			ZZ[][(k+NN/2)+(NN+1)*(l+NN/2)]=module^(-(alpha+1)/2);
		}
	}
}

VhP1 zr;
// Calculamos la transformada inversa
zz[] = dfft(ZZ[],NN+1,1);
zr = real(zz);
plot(zr,zr);

zz[]=DFFT2d(ZZ[],1,NN/2);
zr = real(zz);
plot(zr,zr);

VhP1 uEF0,uEF0Y;
uEF0=real(zz);
uEF0Y=real(zz(y,x));
plot([uEF0,uEF0Y]);

/////////////////////////////////////////////
// Resolvemos el problema de EF: Cavidad 2D//
/////////////////////////////////////////////

Vh3P2per [uEF, uEFY,uEFP];
VhP1dc uEFdX, uEFdY, uEFYdX, uEFYdY; //las derivadas de uEF del paso anterior
VhP2per uprev, uprevY;
VhP1dc Gr; // Para el termino de VMS-Smagorinsky

T0 = 0.;
real TF = 5.;

Reynolds = 8500;
[uEF, uEFY,uEFP] = [uEF0,uEF0Y,0];
if(T0>0){
	readvector("../../Snapshots/Vx_" + Reynolds + "_t_" +T0+ ".txt", real, SolX, 0);
	uEF[] = SolX;
	readvector("../../Snapshots/Vy_" + Reynolds + "_t_" +T0+ ".txt", real, SolY, 0);
	uEFY[] = SolY;
	readvector("../../Snapshots/P_" + Reynolds + "_t_" +T0+ ".txt", real, SolP, 0);
	uEFP[] = SolP;		
}

for(real ti=T0+dt;ti<=TF+epsEF;ti+=dt){
	write("Output.txt","t = " + ti,0,1);
    include "FE_VMS_2D.idp"

	// Guardamos los snapshots 
	write("../../Snapshots/Vx_" + Reynolds + "_t_" +ti+ ".txt", uEF[], 0, 0);
	write("../../Snapshots/Vy_" + Reynolds + "_t_" +ti+ ".txt", uEFY[], 0, 0);	
	write("../../Snapshots/P_" + Reynolds + "_t_" +ti+ ".txt", uEFP[], 0, 0);
}

// Dibujamos la solucion

plot([uEF, uEFY], cmm="FE vel para Re="+Reynolds);
plot(uEFP, cmm="FE pres para Re="+Reynolds);
