///////////////
// FreeROM 
///////////////

/////////////////////////////////////////
//// NS + Smago evolutivo      /////////
////////////////////////////////////////

// Codigo para resolver el problema de EF de VMS-Smago. 
// Elemento Finito P2-P1 (no estable) en vel-pres 

// Cargamos librerias
load "iovtk" 


macro dimension() 2 //EOM
include "macro_ddm.idp"

load "PETSc"

// Cargamos macros
include "../Auxiliary/IO.idp"
include "../Auxiliary/Macros_2D.idp"

// Creamos la malla
include "../Auxiliary/Malla.idp"

// Definimos los parametros a usar junto con las matrices Mat de EF
include "../Auxiliary/Parametros_2D.idp"

MatCreate(Th, MatVhP1dcper, PkP1dc);
{
    macro def(i) [i, iY] // EOM
    macro init(i) [i, i] // EOM
    MatCreate(Th, MatVh2P2per, Pk2P2);
}

MatCreate(Th, MatVhP1per, PkP1);

MatCreate(Th, MatVhP2per, PkP2);

// Matriz del sistema linal
Mat MatFinal;
{
    macro def(i) [i, iY, iP] // EOM
    macro init(i) [i, i, i] // EOM
    MatCreate(Th, MatFinal, Pk3P2);
}


// Definimos los espacios de EF 
include "FE_Spaces_NoStab_VP_2D.idp"


mapVhP1per = restrict(VhP1per, VhP1perG, myN2o);
mapVhP2per = restrict(VhP2per, VhP2perG, myN2o);
mapVhP1dcper = restrict(VhP1dcper, VhP1dcperG, myN2o);
mapVh2P2per = restrict(Vh2P2per,Vh2P2perG,myN2o);

// Definimos las matrices de interpolacion y derivacion
include "Interp_matrix_NoStab_VP_2D.idp"

///////////////////////////////////////////////////////
/// Establecemos la CI para EF: Cavidad 2D periodica///
///////////////////////////////////////////////////////

// Cargamos el modulo para hacer transformadas
include "../Auxiliary/fourier.idp"

VhP1perG <complex> ZZ,zz;
ZZ = 0.;

// Creamos el espectro artificialmente
real module;
for(int k=-NN/2;k<NN/2;k++)
{
	for(int l=-NN/2;l<NN/2;l++)
	{
		module=k^2+l^2;
		if(sqrt(module)<1)
		{
			ZZ[][(k+NN/2)+(NN)*(l+NN/2)]=0.;
		}
		else
		{
			ZZ[][(k+NN/2)+(NN)*(l+NN/2)]=module^(-(alpha+1)/4);
		}
	}
}

// Calculamos la transformada inversa
zz[] = DFFT2d(ZZ[],1,NN/2);
zz[] = zz[]/zz[].max;

VhP1per <complex> zzL;
zzL[] = zz[](mapVhP1per);

VhP1per uEF0,uEF0Y;
uEF0 = real(zzL);
uEF0Y = real(zzL);

real[int] energyk = 0;//espectro2DDFFT(zz[], zz[], NN+1);
write("../Snapshots/Espectro_inicial0.txt", energyk, 0, 0);

/////////////////////////////////////////////
// Resolvemos el problema de EF: Cavidad 2D//
/////////////////////////////////////////////

Vh3P2per [uEF, uEFY,uEFP];
VhP1dcper uEFdX, uEFdY, uEFYdX, uEFYdY; //las derivadas de uEF del paso anterior
VhP2per uprev, uprevY;
VhP1dcper Gr; // Para el termino de Smagorinsky

T0 = 0;
TF = 15;

Reynolds = 8500;
[uEF, uEFY,uEFP] = [uEF0, uEF0Y, 0];

// if(T0>0){
// 	readvector("../Snapshots/Vx_" + Reynolds + "_t_" +T0+ ".txt", real, SolX, 0);
// 	uEF[] = SolX;
// 	readvector("../Snapshots/Vy_" + Reynolds + "_t_" +T0+ ".txt", real, SolY, 0);
// 	uEFY[] = SolY;
// 	readvector("../Snapshots/P_" + Reynolds + "_t_" +T0+ ".txt", real, SolP, 0);
// 	uEFP[] = SolP;
// }



include "FE_Smago_2D.idp"

// Dibujamos la solucion

plotMPI(Th, uEFP, PkP1, def, real, cmm="vel tfinal");
//plot([uEF, uEFY], cmm="FE vel para Re="+Reynolds);
//uprev = uEF^2+uEFY^2;
//plot(uprev, cmm="Modulo presiomn para Re="+Reynolds);
//plot(uEFP, cmm="FE pres para Re="+Reynolds);