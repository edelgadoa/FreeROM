///////////////
// FreeROM 
///////////////

/////////////////////////////////////////
//// NS + VMS-Smago + Estab Pres (LPS)///
/////////////////////////////////////////

// Codigo para resolver el problema de EF de VMS-Smago. 
// Elemento Finito P2-P1 (no estable) en vel-pres 

// Cargamos librerias
load "iovtk" 

// Cargamos macros
include "../Auxiliary/IO.idp"
include "../Auxiliary/Macros_2D.idp"
include "../Auxiliary/macro_ddm.idp"

// Creamos la malla
include "../Auxiliary/Malla.idp"

// Definimos los espacios de EF 
include "FE_Spaces_NoStab_VP_2D.idp"

// Definimos los parametros a usar
include "../Auxiliary/Parametros_2D.idp"

// Definimos las matrices de interpolacion y derivacion
include "Interp_matrix_NoStab_VP_2D.idp"


/////////////////////////////////////////////
/// Establecemos la CI para EF: Cavidad 2D///
/////////////////////////////////////////////

// Cargamos el modulo para hacer transformadas
include "../Auxiliary/fourier.idp"

VhP1 <complex> ZZ,zz;
ZZ = 0.;

// Creamos el espectro artificialmente
real module;
for(int k=-NN/2;k<=NN/2;k++)
{
	for(int l=-NN/2;l<=NN/2;l++)
	{
		module=k^2+l^2;
		if(sqrt(module)<1)
		{
			ZZ[][(k+NN/2)+(NN+1)*(l+NN/2)]=0.;
		}
		else
		{
			ZZ[][(k+NN/2)+(NN+1)*(l+NN/2)]=module^(-(alpha+1)/4);
		}
	}
}

// Calculamos la transformada inversa
zz[]=DFFT2d(ZZ[],1,NN/2);
zz[] = zz[]/zz[].max;

VhP1 uEF0,uEF0Y;
uEF0=real(zz);
uEF0Y=real(zz);

real[int] energyk = espectro2DDFFT(zz[], zz[], NN+1);
write("../Snapshots/Espectro_inicial0.txt", energyk, 0, 0);

/////////////////////////////////////////////
// Resolvemos el problema de EF: Cavidad 2D//
/////////////////////////////////////////////

Vh3P2per [uEF, uEFY,uEFP];
VhP1dc uEFdX, uEFdY, uEFYdX, uEFYdY; //las derivadas de uEF del paso anterior
VhP2per uprev, uprevY;
VhP1dc Gr; // Para el termino de VMS-Smagorinsky

T0 = 0;
TF = 15;

Reynolds = 8500;
[uEF, uEFY,uEFP] = [uEF0,uEF0Y,0];

if(T0>0){
	readvector("../Snapshots/Vx_" + Reynolds + "_t_" +T0+ ".txt", real, SolX, 0);
	uEF[] = SolX;
	readvector("../Snapshots/Vy_" + Reynolds + "_t_" +T0+ ".txt", real, SolY, 0);
	uEFY[] = SolY;
	readvector("../Snapshots/P_" + Reynolds + "_t_" +T0+ ".txt", real, SolP, 0);
	uEFP[] = SolP;
}

include "FE_Smago_2D.idp"

// Dibujamos la solucion
plot([uEF, uEFY], cmm="FE vel para Re="+Reynolds);
uprev = uEF^2+uEFY^2;
plot(uprev, cmm="Modulo presiomn para Re="+Reynolds);
plot(uEFP, cmm="FE pres para Re="+Reynolds);