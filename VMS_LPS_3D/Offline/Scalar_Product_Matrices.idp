///////////////
// FreeROM 
/////////////// 

// Defino las matrices de producto escalar T que voy a considerar para la ortonormalizacion
varf pescT ([uu, uuY, uuZ], [v,vY,vZ]) = int3d(ThL)((1./Refijo + MOD(uFijo))*GradUGradV(uu,v));
matrix MPescT = pescT(Vh3P2L, Vh3P2L);

varf pescX ([uu, uuY, uuZ, uuP], [v, vY, vZ, vP]) = int3d(ThL)((1./Refijo + MOD(uFijo))*GradUGradV(uu,v) + uuP*vP);
matrix MPescX = pescX(Vh4P2L, Vh4P2L);

varf NormaVel([uu,uuY,uuZ],[vv,vvY,vvZ]) = int3d(ThL)(GradUGradV(uu,vv));
Mat MNormaVel = MatAVh3P2;

MNormaVel = NormaVel(Vh3P2L, Vh3P2L);

///////////////////////////////////////////////////////
Mat DiffPEM  = MatAVh3P2;
Mat PenPEM = MatAVhP2;
Mat DivPPEM;
Mat ConvLevPEM = MatAVh3P2;
Mat DTPEM = MatAVh3P2;

varf DiffPE([uu,uuY,uuZ], [v,vY,vZ]) = int3d(ThL)(GradUGradV(uu,v));
{
	DiffPEM = DiffPE(Vh3P2L,Vh3P2L);
	//matrix DiffPEML = DiffPE(Vh3P2L,Vh3P2L);
  	//Mat DiffPEMTemp = DiffPEML;
	//DiffPEM = DiffPEMTemp;
}

varf DivPPE([uu,uuY,uuZ], [vP]) = int3d(ThL)(Div(uu)*vP);
{
	matrix DivPPEMT = DivPPE(Vh3P2L,VhP2L);
    Mat DivPPEMTemp(MatAVhP2, MatAVh3P2, DivPPEMT);
	DivPPEM = DivPPEMTemp;
}

varf PenPE(uP, vP) = int3d(ThL)(epspen*uP*vP);
{
	PenPEM = PenPE(VhP2L, VhP2L);
	//matrix PenPEML = PenPE(VhP2L,VhP2L);
    //Mat PenPEMTemp = PenPEML;
	//PenPEM = PenPEMTemp;
}

varf ConvLevPE([uu,uuY, uuZ], [v,vY,vZ]) = int3d(ThL)(Antisimetric(Lev, uu, v) + Antisimetric(uu, Lev, v));
{
	ConvLevPEM = ConvLevPE(Vh3P2L,Vh3P2L); 
	//matrix ConvLevPEML = ConvLevPE(Vh3P2L,Vh3P2L);
    //Mat ConvLevPEMTemp = ConvLevPEML;
	//ConvLevPEM = ConvLevPEMTemp;
}

varf DTPE([uu,uuY,uuZ], [v,vY,vZ]) = int3d(ThL)(UporV(uu,v));
{
	DTPEM = DTPE(Vh3P2L,Vh3P2L);
	// matrix DTPEML = DTPE(Vh3P2L,Vh3P2L);
    //Mat DTPEMTemp = DTPEML;
	// DTPEM = DTPEMTemp;
}


Mat[int] ConvPEM(Nbases); // Simplemente inicializo, dentro del bucle del greedy definir√© los prod. esc. segun vaya calculando las bases

Mat[int] SmagoPEM(Mbases), StabPPEM(Taubases);
// VMS-SMAGO
{
    for (int s=0; s<Mbases; s++){
        
        varf SmagoPE([uu,uuY,uuZ],[v,vY,vZ]) = int3d(ThL)((CS*hTriangle)^2*EIMSmago[s]*GradUGradV(uu,v));
        {
            matrix SmagoPEML = SmagoPE(Vh3P2L,Vh3P2L);
            Mat SmagoPEMtem(MatAVh3P2, SmagoPEML); // = SmagoPE(Vh3P2L,Vh3P2L);
            SmagoPEM[s] = SmagoPEMtem;
        }
    }
}

// LPS-pressure


{
    for (int s=0; s<Taubases; s++){
        
		varf StabPPE(uP,vP) = int3d(ThL)(EIMTau[s]*uP*vP);
		matrix SPPEM = StabPPE(VhP1dcL, VhP1dcL);
		matrix FiltroX, FiltroY, FiltroZ;
		{
			FiltroX = SPPEM * IPhDXP2L;
			FiltroX = (IPhDXP2L') * FiltroX;
			FiltroY = SPPEM * IPhDYP2L;
			FiltroY = (IPhDYP2L') * FiltroY;
			FiltroZ = SPPEM * IPhDZP2L;
			FiltroZ = (IPhDZP2L') * FiltroZ;	
		}
        matrix SPPEML = FiltroX + FiltroY + FiltroZ;
        // SPPEML = SPPEML + FiltroZ;
	    Mat StabPPEMtem(MatAVhP2, SPPEML);
        StabPPEM[s] =  StabPPEMtem;
    }
}

varf bDiffPE([un, unY, unZ], [v, vY, vZ]) = int3d(ThL)(GradUGradV(Lev, v));
real[int] bDiffPEv = bDiffPE(0, Vh3P2L);

