///////////////
// FreeROM 
/////////////// 

// Código para construir EN PARALELO las matrices de base reducida


// Inicializo las matrices locales para el paralelo
include "Allocate_matrices_local.idp"
real[int] BaseVi, BasePi, FBaseVi;
ChangeNumbering(MatAVh3P2, BaseV[i][], BaseVi);
ChangeNumbering(MatAVhP2, BaseP[i][], BasePi);
ChangeNumbering(MatAVh3P2, FBaseV[i][], FBaseVi);

// Comienzo el bucle de construccion de las matrices reducidas fijas
for (int j=0; j<=i; j++){
	real[int] BaseVj, BasePj;
	ChangeNumbering(MatAVh3P2, BaseV[j][], BaseVj);
	ChangeNumbering(MatAVhP2, BaseP[j][], BasePj);
		
	// Matrices
	DiffRB(i,j) = innerprodX(BaseVi, BaseVj, DiffPEM); 
	DivPRB(i+Nbases, j) = innerprodX(BasePi, BaseVj, DivPPEM);
	ConvLevRB(i,j) = innerprodX(BaseVi, BaseVj, ConvLevPEM);
	DTRB(i,j) = innerprodX(BaseVi, BaseVj, DTPEM);
    PenRB(i+Nbases, j+Nbases) = innerprodX(BasePi, BasePj, PenPEM);
	// StabhkRB(i+Nbases, j+Nbases) = innerprodX(BaseP[i][], BaseP[j][],StabhkPEM);
	
	if (j<i){		
		DiffRB(j,i) = DiffRB(i,j);
		DivPRB(j+Nbases, i) = innerprodX(BasePj, BaseVi, DivPPEM);
		PenRB(j+Nbases, i+Nbases) = PenRB(i+Nbases, j+Nbases);
		ConvLevRB(j,i) = innerprodX(BaseVj, BaseVi, ConvLevPEM);
		DTRB(j,i) = DTRB(i,j);
		// StabhkRB(j+Nbases, i+Nbases) = StabhkRBL(i+Nbases, j+Nbases);
	}	

}

mpi(cout<<"la matriz que quiero comprobar: 1"<<endl;)
mpi(cout<< DiffRB<<endl;)
pause;
mpi(cout<< PenRB<<endl;)
pause;
mpi(cout<<ConvLevRB<<endl;)
pause;
mpi(cout<<DivPRB<<endl;)
pause;
mpi(cout<<DTRB<<endl;)


// mpiAllReduce(DiffRBL, DiffRBG, mpiCommWorld, mpiSUM);
// mpiAllReduce(DivPRBL, DivPRBG, mpiCommWorld, mpiSUM);
// mpiAllReduce(PenRBL, PenRBG, mpiCommWorld, mpiSUM);
// mpiAllReduce(ConvLevRBL, ConvLevRBG, mpiCommWorld, mpiSUM);
// mpiAllReduce(DTRBL, DTRBG, mpiCommWorld, mpiSUM);
// mpiAllReduce(StabhkRBL, StabhkRBG, mpiCommWorld, mpiSUM);

//DiffRB += DiffRBG;
// DivPRB += DivPRBG;
// PenRB += PenRBG;
// ConvLevRB += ConvLevRBG;
// DTRB += DTRBG;
// StabhkRB += StabhkRBG;

// Comienzo el bucle para la construcción de los tensores

// Conveccion
mpi(cout<<"Convection matrix"<<endl;)
for (int s=0; s<=i; s++){
	real[int, int] Cint(2*Nbases, 2*Nbases);
	Cint = ConvRB[s];
	for (int j=0; j<=i; j++){
        real[int] BaseVj;
        ChangeNumbering(MatAVh3P2, BaseV[j][], BaseVj);
		Cint(i,j) = innerprodX(BaseVi, BaseVj, ConvPEM[s]);
		if(j<i){
			Cint(j,i) = innerprodX(BaseVj, BaseVi, ConvPEM[s]);
		}
		if (s==i && (j!=i)){
			for (int k=0; k<s; k++){
                real[int] BaseVk;
                ChangeNumbering(MatAVh3P2, BaseV[k][], BaseVk);
				Cint(k,j) = innerprodX(BaseVk, BaseVj, ConvPEM[s]);
			}
		} 
	
	}
	
	ConvRB[s] = Cint;
}
cout<<"conv Matrix"<<ConvRB[0]<<endl;

// Smagorinsky
mpi(cout<<"Smago matrix"<<endl;)
for (int s=0; s<Mbases; s++){
	real[int, int] Sint(2*Nbases, 2*Nbases);
    Sint = SmagoRB[s];
	for (int j=0; j<=i; j++){
        real[int] FBaseVj;
        ChangeNumbering(MatAVh3P2, FBaseV[j][], FBaseVj);
		Sint(i,j) = innerprodX(FBaseVi, FBaseVj, SmagoPEM[s]);
		if(j<i){
			Sint(j,i) = Sint(i,j);
		}
		
	}
	SmagoRB[s] = Sint;
}
mpi(cout<<"Smago Matrix"<<SmagoRB[0]<<endl;)


// LPS
mpi(cout<<"Stab matrix"<<endl;)
for (int s=0; s<Taubases; s++){
	real[int, int] LPSint(2*Nbases, 2*Nbases);
	LPSint = StabPRB[s];
	for (int j=0; j<=i; j++){
        real[int] BasePj;
        ChangeNumbering(MatAVhP2, BaseP[j][], BasePj);
		LPSint(i + Nbases,j + Nbases) = innerprodX(BasePi, BasePj, StabPPEM[s]); 
		if(j<i){
			LPSint(j + Nbases,i + Nbases) = LPSint(i + Nbases,j + Nbases);
		}
	}
	StabPRB[s] = LPSint;
}
mpi(cout<<"LPS Matrix"<<StabPRB[0]<<endl;)

// Matrices para el EIM de Smago

int MbasesL;
for (int s=0; s<Mbases; s++){
    real[int,int] Dtk(GradPM[s].n, GradPM[s].m);
    real[int,int] DtkL = GradPM[s];
    
    Dtk = 0;
   
    if (NumberPMSmago(s)>0){
        DtkL(0,i) = FVdX[i][](PuntosMSmagoL(MbasesL));
        DtkL(1,i) = FVdY[i][](PuntosMSmagoL(MbasesL));
        DtkL(2,i) = FVdZ[i][](PuntosMSmagoL(MbasesL));
   
        DtkL(3,i) = FVYdX[i][](PuntosMSmagoL(MbasesL));
        DtkL(4,i) = FVYdY[i][](PuntosMSmagoL(MbasesL));
        DtkL(5,i) = FVYdZ[i][](PuntosMSmagoL(MbasesL));
   
        DtkL(6,i) = FVZdX[i][](PuntosMSmagoL(MbasesL));
        DtkL(7,i) = FVZdY[i][](PuntosMSmagoL(MbasesL));
        DtkL(8,i) = FVZdZ[i][](PuntosMSmagoL(MbasesL));
       
        DtkL *= WeightPMSmago(s);
        MbasesL++;
    }
    mpiAllReduce(DtkL, Dtk, mpiCommWorld, mpiSUM);
    GradPM[s] = Dtk;
}



{
    // Matrices para el EIM LPS (parte del levantamiento)
    real[int, int] Ngk(Nbases+1, Nbases+1), Nggk(Nbases+1, Nbases+1);
    real[int, int] NgkL(Nbases+1, Nbases+1), NggkL(Nbases+1, Nbases+1);
    Ngk = 0; Nggk = 0; NgkL = 0; NggkL = 0;

    int TauBasesL;
    
	//real[int,int] Ngk = NUK[s];
	VhP2L fvel, fvelY, fvelZ;
	varf NG(un,v) = int3d(ThL)(UporV(fvel, Lev)*v);
	fvel = BaseVel[i]; fvelY = BaseVelY[i]; fvelZ = BaseVelZ[i];

    real[int] ngaux = NG(0,VhP0L);

	///////////////////////////////////////////////

	//real[int,int] Nggk = NGUK[s];
	VhP1dc dxfv1, dyfv1, dzfv1, dxfv2, dyfv2, dzfv2, dxfv3, dyfv3, dzfv3;
	varf NDG(un,v) = int3d(ThL)((dxfv1*FLevdX + dyfv1*FLevdY + dzfv1*FLevdZ 
			 				  + dxfv2*FLevYdX + dyfv2*FLevYdY + dzfv2*FLevYdZ
							  + dxfv3*FLevZdX + dyfv3*FLevZdY + dzfv3*FLevZdZ  )*v); 
						  
	dxfv1 = FVdX[i]; dyfv1 = FVdY[i]; dzfv1 = FVdZ[i]; 
	dxfv2 = FVYdX[i]; dyfv2 = FVYdY[i]; dzfv2 = FVYdZ[i];
	dxfv3 = FVZdX[i]; dyfv3 = FVZdY[i]; dzfv3 = FVZdZ[i]; 

    real[int] ndgaux = NDG(0,VhP0L);
    
    for (int s=0; s<Taubases; s++){ 
   
        if (NumberPMTau(s)>0){
    	    NgkL(0,1+i) = ngaux(PuntosMTauL(TauBasesL));		

    	    //Matriz simétrica
    	    NgkL(1+i,0) = NgkL(0,1+i);
        
            NgkL *= WeightPMTau(s);
        
            ////--------------///////
        
        	NggkL(0,1+i) = ndgaux(PuntosMTauL(TauBasesL));
        	//Matriz simétrica
        	NggkL(1+i,0) = NggkL(0,1+i);
        
            NggkL *= WeightPMTau(s);
        
            TauBasesL++;  
        }
        mpiAllReduce(NgkL, Ngk, mpiCommWorld, mpiSUM);
        mpiAllReduce(NggkL, Nggk, mpiCommWorld, mpiSUM);
    
        NUK[s] += Ngk;
    	NGUK[s] += Nggk;
    }
}

{
	// Matrices para el EIM LPS (Funciones de base)
    real[int, int] Ngk(Nbases+1, Nbases+1), Nggk(Nbases+1, Nbases+1);
    real[int, int] NgkL(Nbases+1, Nbases+1), NggkL(Nbases+1, Nbases+1);
    Ngk = 0; Nggk = 0; NgkL = 0; NggkL = 0;
    
    
	for (int j=0; j<=i; j++){ 

		VhP2 fvel, fvelY, fvelZ, ffvel, ffvelY, ffvelZ;
		varf NGL(un,v) = int3d(ThL)(UporV(fvel,ffvel)*v);
	
		fvel = BaseV[i]; fvelY = BaseVY[i]; fvelZ = BaseVZ[i]; 
		ffvel = BaseV[j]; ffvelY = BaseVY[j]; ffvelZ = BaseVZ[i];
	
		real[int] ngaux = NGL(0,VhP0L);
    
    
        ///////////////////////////////////////////
    
		VhP1dc dxfv1, dyfv1, dzfv1, dxfv2, dyfv2, dzfv2, dxfv3, dyfv3, dzfv3,
			   DXFV1, DYFV1, DZFV1, DXFV2, DYFV2, DZFV2, DXFV3, DYFV3, DZFV3;
	
	    varf NDG(un,v) = int3d(ThL)((dxfv1*DXFV1 + dyfv1*DYFV1 + dzfv1*DZFV1 
			                      + dxfv2*DXFV2 + dyfv2*DYFV2 + dzfv2*DZFV2
								  + dxfv3*DXFV3 + dyfv3*DYFV3 + dzfv3*DZFV3 )*v);
	
	
		dxfv1 = FVdX[i]; dyfv1 = FVdY[i]; dzfv1 = FVdZ[i]; 
		dxfv2 = FVYdX[i]; dyfv2 = FVYdY[i]; dzfv2 = FVYdZ[i];
		dxfv3 = FVZdX[i]; dyfv3 = FVZdY[i]; dzfv3 = FVZdZ[i]; 
	
		DXFV1 = FVdX[j]; DYFV1 = FVdY[j]; DZFV1 = FVdZ[j];
		DXFV2 = FVYdX[j]; DYFV2 = FVYdY[j]; DZFV2 = FVYdZ[j];
		DXFV3 = FVZdX[j]; DYFV3 = FVZdY[j]; DZFV3 = FVZdZ[j];
	
		real[int] ndgaux = NDG(0,VhP0L);
    
        int TauBasesL;
        for (int s=0; s<Taubases; s++){
    	
        
    		if (NumberPMTau(s)>0){	
        
                NgkL(1+i,1+j) = ngaux(PuntosMTauL(TauBasesL));				
        		if(j<i){
        			NgkL(1+j,1+i) = Ngk(1+i,1+j);
        		}
            
                NgkL *= WeightPMTau(s);
        		/////-----------////
	
        		NggkL(1+i,1+j) = ndgaux(PuntosMTauL(TauBasesL));		
        		if(j<i){
        			NggkL(1+j,1+i) = Nggk(1+i,1+j);
        		}
                NggkL *= WeightPMTau(s);
        
                TauBasesL++;
            }
		  
            mpiAllReduce(NgkL, Ngk, mpiCommWorld, mpiSUM);
            mpiAllReduce(NggkL, Nggk, mpiCommWorld, mpiSUM);
	
    	    NUK[s] += Ngk;
    	    NGUK[s] += Nggk;
        }
    }
}

mpi(cout<<"NUK"<<endl<<NUK[0]<<endl;)
mpi(cout<<"NGUK"<<endl<<NGUK[0]<<endl;)

//mpi(cout<<"RHS"<<endl;)
// Definicion de segundos miembros
real[int] LevVB, FLevVB;
ChangeNumbering(MatAVh3P2, LevV[],LevVB);
ChangeNumbering(MatAVh3P2, FLev[], FLevVB);
bDiffRB(i) = innerprodX(BaseVi, LevVB, DiffPEM);
bConvRB(i) = innerprodX(BaseVi, LevVB, ConvLevPEM)/2; // Lo divido entre 2 por la definicion de esa matriz
mpi(cout<<"bDiff"<<endl<<bDiffRB<<endl;)
mpi(cout<<"bConv"<<endl<<bConvRB<<endl;)
for (int s=0; s<Mbases; s++){
		bSmagoRB(s,i) = innerprodX(FBaseVi, FLevVB, SmagoPEM[s]);
}

mpi(cout<<"bsmago"<<endl<<bSmagoRB<<endl;)
