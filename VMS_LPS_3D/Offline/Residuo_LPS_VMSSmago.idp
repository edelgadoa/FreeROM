///////////////
// FreeROM 
/////////////// 

// Programa que calcula el residuo de la soluci√≥n de RBM
matrix MRes;
real[int] bRes(Vh4P2L.ndof);

// Termino de Navier-Stokes
real[int] bNSRes(Vh4P2L.ndof);


{
	varf NSRes([u,uY,uZ,uP],[v,vY,vZ,vP]) = int3d(ThL)((1./Refijo + MOD(uFijo))*GradUGradV(u,v) + uP*vP)
											// Segundo miembro
										  + int3d(ThL)(nuRB*GradUGradV(uRB,v) + Antisimetric(uRB,uRB,v) - Div(v)*uRBP + Div(uRB)*vP)
										  + on(1,2, u=0, uY=0, uZ=0);
    MRes = NSRes(Vh4P2L, Vh4P2L);
	set(MRes, sparams = "-pc_type lu -ksp_type gmres -ksp_converged_reason"); // TODO: probar con otros parametros									
	bNSRes = NSRes(0, Vh4P2L);
}
								
// Termino residuo VMS-Smagorinsky
real[int] bSmagoRes(Vh4P2L.ndof); 

{
	real[int] bSx(Vh4P2L.ndof), bSy(Vh4P2L.ndof), bSz(Vh4P2L.ndof), bSaux(Vh4P1dcL.ndof);
	VhP1dcL uFRB, uFRBY, uFRBZ;
	VhP1dcL GrN = MOD(uRB);
	varf SmagoRes([u,uY,uZ,uP],[v,vY,vZ,vP]) = int3d(ThL)((CS*hTriangle)^2*GrN*UporV(uFRB,v));
	
	// Componente X
	uFRB = uRBdX; uFRBY = uRBYdX; uFRBZ = uRBZdX;
	bSaux = SmagoRes(0, Vh4P1dcL);
	bSx = DX4P2IPhL'*bSaux;
	
	// Componente Y
	uFRB = uRBdY; uFRBY = uRBYdY; uFRBZ = uRBZdY;
	bSaux = SmagoRes(0, Vh4P1dcL);
	bSy = DY4P2IPhL'*bSaux;
	
	// Componente Z
	uFRB = uRBdZ; uFRBY = uRBYdZ; uFRBZ = uRBZdZ;
	bSaux = SmagoRes(0, Vh4P1dcL);
	bSz = DZ4P2IPhL'*bSaux;
	
	bSmagoRes = bSx + bSy;
	bSmagoRes += bSz;
	bSmagoRes = bSmagoRes.*cc; // bloqueo de las condiciones de contorno

}

//mpi(cout<<bSmagoRes<<endl;)
// Termino LPS
real[int] bStabPRes(Vh4P2L.ndof);

{
	VhP0L tKres, tKTres, taures;
	varf tauKres(un,v) = int3d(ThL)(UporV(uRB, uRB)*v);
	varf tauKTres(un,v) = int3d(ThL)((MOD(uRB)^2)*v);
	real[int] tK = tauKres(0, VhP0L);
	real[int] tKT = tauKTres(0, VhP0L);
	tKres[] = sqrt(tK); tKTres[] = sqrt(tKT);
	
	taures = ((cc1*(nuRB+((CS*hTriangle)^2)*(tKTres/mk))/hTriangle^2) + (cc2*(tKres/mk)/hTriangle))^(-1.); 
	
	VhP1dcL uFRBP;
	varf StabPRes(unP,vP) = int3d(ThL)(taures*uFRBP*vP);
	
	real[int] bSPx(Vh4P2L.ndof), bSPy(Vh4P2L.ndof), bSPz(Vh4P2L.ndof), bSPaux(VhP1dcL.ndof);
	// Componente X
	uFRBP[] = IPhDXP2L * uRBP[];
	bSPaux = StabPRes(0, VhP1dcL);
	bSPx = IPhD4X4P2L'*bSPaux;  
	
	// Componente Y
	uFRBP[] = IPhDYP2L * uRBP[];
	bSPaux = StabPRes(0, VhP1dcL);
	bSPy = IPhD4Y4P2L'*bSPaux;  
	
	// Componente Z
	uFRBP[] = IPhDZP2L * uRBP[];
	bSPaux = StabPRes(0, VhP1dcL);
	bSPz = IPhD4Z4P2L'*bSPaux; 

	bStabPRes = bSPx + bSPy; 
	bStabPRes += bSPz;
}
//mpi(cout<<bStabPRes<<endl;)

bRes = bNSRes;
bRes += bSmagoRes;
bRes += bStabPRes;

{
	Vh4P2L [RES, RESY, RESZ, RESP];
	mpi(cout<<"Resuelvo el residuo"<<endl;)
	RES[] = MRes^-1*bRes;  
	ResG(iRB) = normX(RES[], MPescX);
}