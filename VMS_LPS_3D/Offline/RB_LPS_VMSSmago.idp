///////////////
// FreeROM 
/////////////// 	

// Comenzamos a resolver el problema reducido	
real errRB = 1.;

matrix MRBV, MRBP; // Matrix para las interacciones Velocidad-Velocidad	 y Presion-Presion
	
MRBV = nuRB * DiffRBi;
//mpi(cout<<MRBV<<endl;)
//MRBVP += DivPRBi;
//MRBVP += DivPRBTi;
MRBV = MRBV +(1./dt) * DTRBi;
//mpi(cout<<MRBV<<endl;)
MRBV = MRBV + ConvLRBi;
// mpi(cout<<MRBV<<endl;)
MRBP = PenRBi;	
// mpi(cout<<MRBP<<endl;)

// MRBP = MRBP + StabhkRBs;

// bDiffRBi = bDiffRBG(0:2*I-1);


	
for (int iN=0; iN<=niterRB && (errRB>epsRB); iN++){
	matrix MRBFV = MRBV;
	matrix MRBFP = MRBP;
	ConvRBi = 0;
	SmagoRBi = 0;
	StabPRBi = 0;
	bDTRBi = 0;
	bSmagoRBi = 0;
	bRB = 0;
	
	// Matriz de conveccion
	for (int s=0; s<I; s++){
		real[int,int] ConvRBint(2*Nbases, 2*Nbases), ConvRBN(I, I);
		ConvRBint = ConvRB[s];
		ConvRBN = ConvRBint(0:I, 0:I);
		ConvRBN = uRBv(s)*ConvRBN;
		ConvRBi += ConvRBN;
	}
	// mpi(cout<<"CONV:"<<endl<<ConvRBi<<endl;)

	// Matiz de Smagorinsky
	real[int] bEIMS(Mbases), sigmaEIMS(Mbases), GraduN(9), uN(I);
	uN = uRBv(0:I-1); //solo las componentes de la velocidad
	for(int s=0; s<Mbases; s++){
		real[int, int] Gradint(9,I);
		Gradint = GradPM[s](0:8, 0:I-1);
		GraduN = Gradint * uN;
		GraduN = GraduN + GradPMLev[s];
		bEIMS(s) = sqrt(GraduN'*GraduN);
	}
	// mpi(cout<<bEIMS<<endl;)
	sigmaEIMS = MEIMS^-1 * bEIMS;
	
	//cout<<"it: "<<iN<<",Proc: "<<mpirank<<endl<<sigmaEIMS<<endl;
	for (int s=0; s<Mbases; s++){
		real[int,int] SmagoRBN(I, I);
		SmagoRBN = SmagoRB[s];
		SmagoRBN = sigmaEIMS(s)*SmagoRBN;
		SmagoRBi += SmagoRBN; 
	}

	//mpi(cout<<"SMAGO:"<<endl<<SmagoRBi<<endl;)
	//mpi(cout<<"--------------------------------"<<endl;)	
	// Segundo miembro Smago
	for (int s=0; s<I; s++){
		bSmagoRBi(s) = sigmaEIMS'*bSmagoRBG(0:Mbases-1,s);
	}
	
	// Matriz LPS
	real[int] uN1(I+1), sigmaEIMTau(Taubases), bEIMTau(Taubases);
	real[int,int] CuN(I+1,I+1);
	uN1(0) = 1;
	uN1(1:I) = uN;
	CuN = uN1*uN1';
	//mpi(cout<<"CuN"<<endl<<CuN<<endl;)
	for (int s=0; s<Taubases; s++){
		real Nuk, Nguk;
		Nuk = 0; Nguk = 0;
		real[int, int] Nuki(I+1,I+1), Nguki(I+1,I+1), Auxi(I+1,I+1);
		
		Nuki = NUK[s](0:I, 0:I);
		Auxi = CuN.*Nuki;
		Nuk = sqrt(Auxi.sum)/mkG[](PuntosMTau(s));
		Nguki = NGUK[s](0:I,0:I);
		Auxi = CuN.*Nguki;
		Nguk = (CS*hkG[](PuntosMTau(s)))^2*sqrt(Auxi.sum)/mkG[](PuntosMTau(s));
		// mpi(cout<<"it:"<<iN<<",s:"<<s<<", Nguk:"<<Nguki<<", Nuk"<<Nuki<<endl;)

		bEIMTau(s) = (cc1*(nuRB+Nguk)/hkG[](PuntosMTau(s))^2 + cc2*Nuk/hkG[](PuntosMTau(s)))^-1;	
		
		//mpi(cout<<"hk^2="<<hkG[](PuntosMTau(s))^2<<endl;)
	}
	// mpi(cout<<"btau"<<bEIMTau<<endl;)
	sigmaEIMTau = MEIMTau^-1*bEIMTau;
	// mpi(cout<<"it:"<<iN<<", Proc: "<<mpirank<<endl<<sigmaEIMTau<<endl;)
	for (int s=0; s<Taubases; s++){
		real[int,int] StabPRBN(I, I);
		StabPRBN = StabPRB[s](0:I-1, 0:I-1);
		StabPRBN = sigmaEIMTau(s)*StabPRBN;
		StabPRBi += StabPRBN; 
	}
	// mpi(cout<<"LPS:"<<endl<<StabPRBi<<endl;)
	// mpi(cout<<"--------------------------------"<<endl;)	
	
	// Segundos miembro dt
	for (int s=0; s<I; s++){
		real[int] bDTRBint(I);
		bDTRBint = DTRBG(s,:);
		bDTRBint = uRBv(s)*bDTRBint;
		bDTRBi += bDTRBint;
	}
	
	// mpi(cout<<"bdt "<< bDTRBi<<endl;)
	
	// Construyo la matriz y Segundo miembros para el problema reducido
	MRBFV += ConvRBi;
	MRBFV += SmagoRBi; 
	MRBFP += StabPRBi;
	
	
	
	bRB = (1./dt) * bDTRBi;
	//mpi(cout<<"bdt: "<<bRB<<endl;)
	bRB -= nuRB * bDiffRBG;
	//mpi(cout<<"-bdiff: "<<bRB<<endl;)
	bRB -= bConvLRBG;
	//mpi(cout<<"-bconvL: "<<bRB<<endl;)
	bRB -= bSmagoRBi;
	//mpi(cout<<"-bSmago: "<<bSmagoRBi<<endl;)
	//mpi(cout<<"bRB="<<bRB<<endl;)
	
	//MRBF = [[MRBV, DivPRBTi],[DivPRBi, MRBP]]; //matriz por bloques
	
	// Resuelvo el problema reducido
	real[int] uRBvp = uRBv;
	matrix MRBs = [[MRBFV, DivPRBTi],[DivPRBi, MRBFP]];
	// mpi(cout<<MRBs<<endl;)
	// mpi(cout<<bRB<<endl;)
	set(MRBs, solver=UMFPACK);
	// real[int,int] MRBinv = MRB^-1;
	
	uRBv = MRBs^-1*bRB;
	mpi(cout<<"uRB:"<<uRBv<<endl;)
	// Actualizo el error 
	real[int] uRBerr(I); 
	uRBerr = uRBv(0:I-1) - uRBvp(0:I-1);
	errRB = uRBerr.l2/uRBv.l2; 
}

