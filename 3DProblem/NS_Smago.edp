// Transitory NS + Smagorinsky with LPS pressure stabilization

load "iovtk"

int[int] fforder=[1,1,1,1];
verbosity = 0;


// Mesh Creation
include "CubeN.idp"

// Macros definition:
macro Div(U) (dx(U) + dy(U#Y) + dz(U#Z)) //EOM
macro GradUGradV(U,V) (dx(U)*dx(V)     + dy(U)*dy(V)     + dz(U)*dz(V) 
					 + dx(U#Y)*dx(V#Y) + dy(U#Y)*dy(V#Y) + dz(U#Y)*dz(V#Y)
					 + dx(U#Z)*dx(V#Z) + dy(U#Z)*dy(V#Z) + dz(U#Z)*dz(V#Z)) //EOM
macro UGradV(U,V)  [[U, U#Y, U#Z]'*[dx(V),   dy(V),   dz(V)], 
				    [U, U#Y, U#Z]'*[dx(V#Y), dy(V#Y), dz(V#Y)],
					[U, U#Y, U#Z]'*[dx(V#Z), dy(V#Z), dz(V#Z)]] //EOM
macro UGradVW(U,V,W) (UGradV(U,V)'*[W, W#Y, W#Z]) //EOM
macro Antisimetric(U,V,W) ( 0.5*(UGradVW(U,V,W) - UGradVW(U,W,V)) ) //EOM
macro MOD(U) (sqrt(dx(U)^2 + dy(U)^2 + dz(U)^2 + 
				   dx(U#Y)^2 + dy(U#Y)^2 + dz(U#Y)^2 +
				   dx(U#Z)^2 + dy(U#Z)^2 + dz(U#Z)^2)) //EOM
macro UporV(U,V) ([U,U#Y,U#Z]'*[V,V#Y,V#Z]) //EOM 

///////////////////

// FE spaces
// Global Mesh
fespace Vh4P2(Th, [P2, P2, P2, P2]); 

// Local Mesh
fespace Vh4P2L(ThL, [P2, P2, P2, P2]); 
fespace VhP2L(ThL, P2); 
fespace VhP1dcL(ThL, P1dc);
fespace VhP1L(ThL, P1);

macro dimension()3 //EOM
include "macro_ddm.idp";
load "PETSc"

Mat MatAVh4P2;

int[int] mapVh4P2;
int[int] myN2o;
macro ThLN2O() myN2o // EOM
buildDmesh(ThL);
mapVh4P2 = restrict(Vh4P2L,Vh4P2,myN2o);  

{
	macro def(i) [i, iY, iZ, iP] //
	macro init(i) [i, i, i, i] // EOM
	createMat(ThL, MatAVh4P2, [P2, P2, P2, P2]); 
}


// Interpolation matrices 
matrix IPhD4X4P2L, IPhD4Y4P2L, IPhD4Z4P2L; // (?) -> Go to Mat structure? (using MatMatMult if necessary)
{
	VhP1dcL faux1 = 1.;
	matrix IdP1dcL = faux1[];
	
	matrix PIg = interpolate(VhP1L,VhP1dcL); //(Id-Ï€h) P1dc->P1->P1dc
	matrix IPg = interpolate(VhP1dcL,VhP1L); 
	matrix IPPIg = IPg*PIg;
	matrix IPhP1dcP1L = IdP1dcL + (-1.)*IPPIg;
	
	int[int] cs2=[3];
	matrix D4X4P2L = interpolate(VhP1dcL,Vh4P2L,U2Vc=cs2,op=1);
	matrix D4Y4P2L = interpolate(VhP1dcL,Vh4P2L,U2Vc=cs2,op=2);
	matrix D4Z4P2L = interpolate(VhP1dcL,Vh4P2L,U2Vc=cs2,op=3);

	IPhD4X4P2L = IPhP1dcP1L * D4X4P2L; 
	IPhD4Y4P2L = IPhP1dcP1L * D4Y4P2L; 
	IPhD4Z4P2L = IPhP1dcP1L * D4Z4P2L;
}

// Parameters for the problem
real CS = 0.1; // Smagorinsky constant

real dt = 1;
real T = 100; // Final time
real epspen = 1e-8;

int niterFE = 1500; 
real epsFE = 1e-8;

real Reynolds = 1000;

// Definition of the Lift function:
func g1=1.*(z>=1);
VhP2L GP2 = g1;
VhP2L GzeroP2 = 0.;

Vh4P2L [Lev, LevY, LevZ, LevP] = [GP2, 0., 0., 0.];

//////////////////////////////
// Start solving the FE Problem
Vh4P2L [uEF, uEFY, uEFZ, uEFP], [uEFp, uEFpY, uEFpZ, uEFpP]; 

matrix MFixed; // (?) -> Change for Mat structure? 
real[int] bFixed(Vh4P2L.ndof);

{
	real nu = 1./Reynolds;

	// Build the fixed matrix 

	varf FVFixed([uu,uuY,uuZ,uP],[v,vY,vZ,vP]) = intN(ThL)( (1./dt)*(UporV(uu,v)) + Div(uu)*vP - Div(v)*uP + nu*GradUGradV(uu, v) 
											              + Antisimetric(uu, Lev, v) + Antisimetric(Lev, uu, v) + epspen*uP*vP )
											  // RHS
									   	   	  - intN(ThL)(Antisimetric(Lev,Lev,v) + nu*GradUGradV(Lev,v))
									          + on(1,2, uu=0., uuY=0., uuZ=0.); 
											 
	// Ensambling the matrix and RHS
	MFixed = FVFixed(Vh4P2L,Vh4P2L, tgv=1); // For having mean pressure ~ 0
	bFixed = FVFixed(0,Vh4P2L, tgv=-1);  // For having mean pressure ~ 0
}

// Start the loop in time
for (real ittime = 0; ittime <= T; ittime += dt){
	if (mpirank==0){ cout<<"Time = "<<ittime<<endl;}
	
	// Convective term
	matrix MNS;
	real[int] bNS(Vh4P2L.ndof);
	{
		varf FVNS ([uu,uuY,uuZ,uuP],[v,vY,vZ,vP])= intN(ThL)(Antisimetric(uEF, uu, v))			
										  		// RHS
										 	   	 + intN(ThL)((1./dt)*UporV(uEF,v));
				
						
		MNS = FVNS(Vh4P2L,Vh4P2L); 
		bNS = FVNS(0,Vh4P2L); 
	}
	
	// Smagorinsky term
	matrix Smago;
	real[int] bSmago(Vh4P2L.ndof);
	{
		VhP1dcL Gr = MOD(uEF);
		varf FVSmago([uu,uuY,uuZ,pun],[v,vY,vZ,qun]) = intN(ThL)((CS*hTriangle)^2*Gr*GradUGradV(uu,v))
													//RHS
													 - intN(ThL)((CS*hTriangle)^2*Gr*GradUGradV(Lev,v));
		Smago = FVSmago(Vh4P2L,Vh4P2L);
		bSmago = FVSmago(0,Vh4P2L);
	}
	
	// LPS Stabilization term
	matrix LPSpres;
	{
		varf termPres(pp,q) = int3d(ThL)(hTriangle^2*pp*q);
		matrix TermP = termPres(VhP1dcL,VhP1dcL);

		matrix DDxx, DDyy, DDzz;
	
		DDxx = TermP * IPhD4X4P2L; 
		DDxx = IPhD4X4P2L' * DDxx;
		
		DDyy = TermP * IPhD4Y4P2L; 
		DDyy = IPhD4Y4P2L' * DDyy;
		
		DDzz = TermP * IPhD4Z4P2L; 
		DDzz = IPhD4Z4P2L' * DDzz;
	

		LPSpres = DDxx + DDyy + DDzz;
	}
	
	// Matrix of the system
	matrix MFinal;
	real[int] bFinal(Vh4P2L.ndof);
	{
		MFinal = MFixed;
		MFinal = MFinal + MNS;
		MFinal = MFinal + Smago;
		MFinal = MFinal + LPSpres;
		// RHS
		bFinal = bFixed;
		bFinal = bFinal + bNS;
		bFinal = bFinal + bSmago;
	}
	
	uEFp[] = uEF[]; // Save the previous iteration
	
	// Solve the system
	MatAVh4P2 = MFinal;
    Vh4P2L [uuL, uuLY, uuLZ, uuLP] = [1.0, 1.0, 1.0, 2.0];
    string[int] names(2);
    names[0] = "velocity";
    names[1] = "pressure";
	
	// (?) MAIN PROBLEM: HOW TO DECIDE THE BETTER CONFIGURATION OF PARAMETER FOR SOLVING THE LINEAR SYSTEM
	/*
	set(MatAVh4P2, prefix = "block_", sparams = "-block_pc_type fieldsplit -block_ksp_type fgmres -block_pc_fieldsplit_type schur  -block_pc_fieldsplit_schur_fact_type lower -block_pc_fieldsplit_detect_saddle_point "
	 + " -block_fieldsplit_velocity_pc_type lu -block_fieldsplit_velocity_mat_solver_type mumps"
	 + " -block_ksp_monitor -block_ksp_view", fields = uuL[], names = names); // (?) -> what should be the best configuration of parameters: 
	  */ 
	
	//(?) -> This configuation ->
	set(MatAVh4P2, sparams = "-pc_type lu -pc_factor_mat_solver_type mumps"); // -> works, but it gets slower when increasing the number of processors.
	if (mpirank==0){ cout<<"Solve the linear system"<<endl;}   
	uEF[] = MatAVh4P2^-1*bFinal; 
	
	
	// (?) -> Other possibilities???
	
}