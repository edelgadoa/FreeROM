///////////////
// FreeROM 
///////////////

// Codigo que calcula las matrices usadas para el RBF modelo VMS_Smago con LPS en presion 
readvector("../../Snapshots/VMS_Smago_LPS_pres_2D/Snapshots.txt", real, ReSnapshots, 0);

Vh3P2 [uEF, uEFY, uEFP]; // Ser√°n las soluciones para el Re_fijo
VhP1dc uEFdX, uEFdY, uEFYdX, uEFYdY; //las derivadas de uEF del paso anterior CON LEVANTAMIENTO
VhP2 SnapX, SnapY, SnapP; 

if (search(ReSnapshots, Reynolds, 1.e-9)==-1){
	// Defino las variables que usaremos para obtener la solucion de EF

	VhP2 uprevL, uprevLY; // La sol del paso anterior con Levantamiento
	VhP1dc Gr; // Para el termino de VMS-Smagorinsky
	
	Reynolds = Refijo;
	include "../../Full_Order/VMS_Smago_LPS_pres_2D/FE_VMS_LPS_2D.idp"
	
	uEF[] += Lev[];
	
	SnapX = uEF;
	SnapY = uEFY;
}
else{
	readvector("../../Snapshots/VMS_Smago_LPS_pres_2D/Vx_" + Refijo + ".txt", real, SolX, 0);
	SnapX[] = SolX;
	readvector("../../Snapshots/VMS_Smago_LPS_pres_2D/Vy_" + Refijo + ".txt", real, SolY, 0);
	SnapY[] = SolY;
	readvector("../../Snapshots/VMS_Smago_LPS_pres_2D/P_" + Refijo + ".txt", real, SolP, 0);
	SnapP[] = SolP;
	
	SnapX = SnapX + Lev;
	SnapY = SnapY + LevY;
	
	[uEF, uEFY, uEFP] = [SnapX, SnapY, SnapP];
}

// Calculo las derivadas de la solucion CON LEVANTAMIENTO
{
	VhP2 udcAux;
	udcAux[] = IPhP2P1*SnapX[];
	uEFdX[] = DXP2*udcAux[]; uEFdY[] = DYP2*udcAux[];

	udcAux[] = IPhP2P1*SnapY[];
	uEFYdX[] = DXP2*udcAux[]; uEFYdY[] = DYP2*udcAux[];
}
Vh3P1dc [uEFf, uEFfY, uEFfP];


// Calculo la matriz correspondiente a la Derivada direccional del operador
varf DerA([uu, uuY, uuP], [v,vY,vP]) = int2d(Th)(1./Refijo * GradUGradV(uu,v) + Div(uu)*vP -  Div(v)*uuP  + UGradVW(uEF, uu, v) + UGradVW(uu, uEF, v))
									 + on (1,2,3,4, uu=0, uuY=0); 
matrix DA = DerA(Vh3P2, Vh3P2);

varf DerSmago([uu, uuY, uuP], [v,vY,vP]) = int2d(Th)((CS*hTriangle)^2*MOD(uEF)*(uu*v + uuY*vY) 
	 											   + (CS*hTriangle)^2/MOD(uEF)*(uEFf*uu+uEFY*uuY)*(uEFf*v+uEFY*vY));

matrix MS = DerSmago(Vh3P1dc,Vh3P1dc);													 
matrix DXMS,DYMS;
{
	matrix Maux; 
	//COMPONENTE X
	Maux=DX3P2*IPh3P23P1;
	uEFf[] = Maux*uEF[];
	DXMS=(Maux')*MS;
	DXMS=DXMS*Maux;

	//COMPONENTE Y
	Maux=DY3P2*IPh3P23P1;
	uEFf[] = Maux*uEF[];
	DYMS=(Maux')*MS;
	DYMS=DYMS*Maux;
}

varf damultb([uu, uuY, uuP], [v,vY,vP])= -int2d(Th)(vP) + on (1,2,3,4, uu=0, uuY=0); 

matrix Fvb = DA + DXMS + DYMS;
real[int] Fmb=damultb(0,Vh3P2);

Fb = [[Fvb, Fmb],[Fmb', 1]];
											 
									 
												

