///////////////
// FreeROM 
///////////////

// Código para aproximar mediante RBF los valores de las constantes inf-sup del estimador de error

// Este código lo calcula para un VMS-Smagorinsky con estabilización LPS en la presión.


/////////////////////////////////////////////////////////////////////
// Cargamos librerías
load "lapack"

// Cargamos macros y funciones varias
include "../../Auxiliary/Macros_2D.idp"
include "../../Auxiliary/search.idp"
include "../../Auxiliary/IO.idp"
include "../../Auxiliary/powermethod.idp"
include "../../Auxiliary/betas.idp"


// Creamos la malla
include "../../Mallas/CuadradoNxNy.idp"

// Definimos los espacios de EF y de los EF globales
include "../../Full_Order/VMS_Smago_LPS_pres_2D/FE_Spaces_NoStab_VP_2D.idp"

// Definimos las matrices de interpolacion y derivacion
include "../../Full_Order/VMS_Smago_LPS_pres_2D/Interp_matrix_NoStab_VP_2D.idp"

// Definimos los parametros a usar
include "../../Full_Order/VMS_Smago_LPS_pres_2D/Parametros_2D.idp"

// Incluimos el levantamiento
include "../../Full_Order/VMS_Smago_LPS_pres_2D/Levantamiento.idp"


////////////////////////////////////////////////////////////////
// Definimos parámetros propios del RBF
real Ninitpoints = 6; // Numero de puntos de interpolacion inicial
real Nmaxpoints = 40; // Numero maximo de puntos de interporlacion
real Nfine = 10000;  // Puntos de la interpolacion fina del intervalo parametrico

real[int] betaI(Nmaxpoints); //vector donde guardo los valores de beta de los ptos de interpolacion	
real[int] gamma0(Nmaxpoints+2); //vector donde guardo los coeficientes del RBF

real [int] vmuI(Nmaxpoints); //Vector con los valores de los parametros en los puntos de interpolacion inicial
real [int] vmufine(Nfine); //Vector con los valores de los parametros para la discretizacion fina

for(int i=0; i<Ninitpoints; i++){
	vmuI(i)=Remin+i*(Remax-Remin)/(Ninitpoints-1);
}

cout<<vmuI<<endl;

for(int i=0; i<Nfine; i++){
	vmufine(i)=Remin+i*(Remax-Remin)/(Nfine-1);
}

// Calculo los valores de beta_h para cada uno de los valores de vReI y la matriz del producto escalar (mu_barra)
real Refijo = 1000;
matrix Fb, X;

{include "Matriz_prodesc_RBF.idp"}

// Inicio el bucle donde calculo cada uno de los \beta_h de vReI
for (int ni=0; ni<Ninitpoints; ni++){
	Reynolds = vmuI(ni);
	cout<<"----------- Re = "<<Reynolds;
	
	{include "Matriz_Derivada.idp"}
	
	real[int] Potencia = powermethodRBF(X, Fb);
	
	betaI(ni) = sqrt(1./Potencia[0]); //La raíz cuadrada del inverso del máximo autovalor
	cout<<", beta_h = "<<betaI(ni)<<" -----------"<<endl;
}

// Comienzo con el método adaptativo para mejorar 
