///////////////
// FreeROM 
///////////////

// Código para aproximar mediante RBF los valores de las constantes inf-sup del estimador de error

// Este código lo calcula para un VMS-Smagorinsky con estabilización LPS en la presión.


/////////////////////////////////////////////////////////////////////
// Cargamos librerías
load "lapack"

// Cargamos macros y funciones varias
include "../../Auxiliary/Macros_2D.idp"
include "../../Auxiliary/search.idp"
include "../../Auxiliary/IO.idp"
include "../../Auxiliary/powermethod.idp"


// Creamos la malla
include "../../Mallas/CuadradoNxNy.idp"

// Definimos los espacios de EF y de los EF globales
include "../../Full_Order/VMS_Smago_LPS_pres_2D/FE_Spaces_NoStab_VP_2D.idp"

// Definimos las matrices de interpolacion y derivacion
include "../../Full_Order/VMS_Smago_LPS_pres_2D/Interp_matrix_NoStab_VP_2D.idp"

// Definimos los parametros a usar
include "../../Full_Order/VMS_Smago_LPS_pres_2D/Parametros_2D.idp"

// Incluimos el levantamiento
include "../../Full_Order/VMS_Smago_LPS_pres_2D/Levantamiento.idp"



////////////////////////////////////////////////////////////////
// Definimos parámetros propios del RBF
real Ninitpoints = 6; // Numero de puntos de interpolacion inicial
real Nmaxpoints = 40; // Numero maximo de puntos de interporlacion
real Nfine = 10000;  // Puntos de la interpolacion fina del intervalo parametrico

real[int] betaI(Nmaxpoints); //vector donde guardo los valores de beta de los ptos de interpolacion	
real[int] gamma0(Nmaxpoints+2); //vector donde guardo los coeficientes del RBF

real [int] vReI(Nmaxpoints); //Vector con los valores de los parametros en los puntos de interpolacion inicial
real [int] vRefine(Nfine); //Vector con los valores de los parametros para la discretizacion fina

for(int i=0; i<Ninitpoints; i++){
	vReI(i)=Remin+i*(Remax-Remin)/(Ninitpoints-1);
}


for(int i=0; i<Nfine; i++){
	vRefine(i)=Remin+i*(Remax-Remin)/(Nfine-1);
}

// Calculo los valores de beta_h para cada uno de los valores de vReI y la matriz del producto escalar (mu_barra)
real Refijo = 1000;
matrix Fb, X;

{include "Matriz_prodesc_RBF.idp"}

// Inicio el bucle donde calculo cada uno de los \beta_h de vReI
for (int ni=0; ni<Ninitpoints; ni++){
	Reynolds = vReI(ni);
	cout<<"beta_h para Re="<<Reynolds<<endl;
	
	{include "Matrices_RBF.idp"}
	Vh3P2 [init, initY, initP] = [0.1, 0.2, 0.4];
	real[int] initPot = [init[], 1];
	cout<<"iniciamos potencia"<<endl;
	real[int] Potencia = powermethodRBF(X, Fb, initPot); 
	betaI(ni) = sqrt(1./Potencia[0]); //La raíz cuadrada del inverso del máximo autovalor
	cout<<"beta_h="<<betaI(ni)<<endl;
}

// Comienzo con el método adaptativo para mejorar 
