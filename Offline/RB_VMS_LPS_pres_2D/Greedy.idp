///////////////
// FreeROM 
/////////////// 

// Inicializamos los vectores donde almacenaré los residuos y estimadores de cada iteración del Greedy
real[int] TauN(Ntrain), DeltaN(Ntrain), ErrVel(Ntrain), ErrPres(Ntrain);

// Inicializamos las matrices para el problema reducido
real[int, int] DiffRBi(2*i, 2*i), DivPRBi(2*i, 2*i), DivPRBTi(2*i, 2*i), PenRBi(2*i, 2*i),
			   ConvLevRBi(2*i, 2*i), DTRBi(2*i, 2*i), ConvRBi(2*i, 2*i), SmagoRBi(2*i, 2*i),
			   StabPRBi(2*i, 2*i); 
			   			   			 			  
// Inicializamos los segundos miembros
real[int] bDiffRBi(2*i), bSmagoRBi(2*i), bDTRBi(2*i), bConvRBi(2*i); 

// Matrices fijas 
DiffRBi = DiffRB(0:2*i-1, 0:2*i-1);
DivPRBi = DivPRB(Nbases-i:Nbases+i-1, 0:2*i-1);
DivPRBTi = DivPRBi'; DivPRBTi = (-1)*DivPRBTi;
PenRBi = PenRB(Nbases-i:Nbases+i-1, Nbases-i:Nbases+i-1);
ConvLevRBi = ConvLevRB(0:2*i-1, 0:2*i-1);
DTRBi = DTRB(0:2*i, 0:2*i);

bDiffRBi = bDiffRB(0:2*i-1);
bConvRBi = bConvRB(0:2*i-1);

real[int] uRBv(2*i), uRBvp(2*i); // Vectores donde almaceno la Solución Reducida

real[int,int] MRB(2*i,2*i); // Matriz para resolver el sistema
real[int] bRB(2*i); // Segundo miembro para resolver el sistema

// Comenzamos el bucle del greedy 

for (int iRB=0; iRB<Ntrain; iRB++){
	
	mpi(cout<<"----Reynolds= "<<muTrain(iRB)<<"-----------"<<endl;)
	real nuRB = 1./muTrain(iRB);
	
	// Resuelvo el problema 
	include "RB_LPS_VMSSmago.idp"
	
	// Reconstruyo la solución reducida
	Vh2P2 [uRB, uRBY];
	VhP2 uRBP;
	
	real[int,int] MBaseVi(Vh2P2.nodf, i), MBasePi(VhP2.ndof, i); // Matrices intermedias
	MBaseVi = MBaseV(0:Vh2P2.ndof-1, 0:i-1);
	MBasePi = MBaseP(0:VhP2.ndof-1, 0:i-1);
	
	uRB[] = MBaseVi*uRBv(0:i-1);
	uRBP[] = MBasePi*uRBv(i:2*i-1);
	
	uRB = uRB + Lev;
	uRBY = uRBY + LevY;
	
	// Calculo el estimador de error 
	include "Residuo_LPS_VMSSmago.idp"	

}
