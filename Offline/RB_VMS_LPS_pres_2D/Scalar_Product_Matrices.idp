///////////////
// FreeROM 
/////////////// 

varf DiffPE([uu,uuY], [v,vY]) = int2d(Th)(GradUGradV(uu,v));
matrix DiffPEM = DiffPE(Vh2P2,Vh2P2);

varf DivPPE([uu,uuY], [vP]) = int2d(Th)(Div(uu)*vP);
matrix DivPPEM = DivPPE(Vh2P2, VhP2);

varf PenPE(uP, vP) = int2d(Th)(epspen*uP*vP);
matrix PenPEM = PenPE(VhP2, VhP2);

varf ConvLevPE([uu,uuY], [v,vY]) = int2d(Th)(UGradVW(Lev, uu, v) + UGradVW(uu, Lev, v));
matrix ConvLevPEM = ConvLevPE(Vh2P2, Vh2P2);

varf DTPE([uu,uuY], [v,vY]) = int2d(Th)(UporV(uu,v));
matrix DTPEM = DTPE(Vh2P2, Vh2P2);

matrix[int] ConvPEM(Nbases); // Simplemente inicializo, dentro del bucle del greedy definir√© los prod. esc. segun vaya calculando las bases

matrix[int] SmagoPEM(Mbases), StabPPEM(Taubases);
{ 
	int contS = 0; 
	for int(s=0; s<Mbases; s++){
		if(mpirank==contS%mpisize){
			// Matrices Smago
			varf SmagoPE([uu,uuY],[v,vY]) = int2d(Th)((Cs*hTriangle)^2*EIMSmago[s]*UPorV(uu,v));
			matrix SPEM = SmagoPE(Vh2P2, Vh2P2);
			matrix FiltroX, FiltroY;
			{
				FiltroX = (DX3P2IPh') * SPEM;
				FiltroX = SPEM * DX2P2IPh;
				FiltroY = (DY3P2IPh') * SPEM;
				FiltroY = SPEM * DY2P2IPh
			}
			SmagoPEM[s] = FiltroX + FiltroY;
		}
		contS++;
	}
	contS = 0;
	for int(s=0; s<Taubases; s++){
		if(mpirank==contS%mpisize){
			// Matrices LPS
			varf StabPPE(p,q)=int2d(Th)(EIMTau[s]*p*q);
			matrix SPPEM = StabPPE(VhP2, VhP2);
			matrix FiltroX, FiltroY;
			{
				FiltroX = SPPEM * IPhDXP2;
				FiltroX = (IPhDXP2') * FiltroX;
				FiltroY = SPPEM * IPhDYP2;
				FiltroY = (IPhDYP2') * FiltroY;	
			}
			StabPPEM[s] = FiltroX + FiltroY;
		}
	}
}