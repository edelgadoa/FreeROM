///////////////
// FreeROM 
/////////////// 

// Código para construir EN PARALELO las matrices de base reducida

// Inicializo las matrices locales para el paralelo
include "Allocate_matrices_local.idp"


// Comienzo el bucle de construccion de las matrices reducidas fijas
int contFF = 0; // Contador para el paralelo
for (int j=0; j<=i; j++){
	if (mpirank==contFF%mpisize){
		// Matrices
		DiffRBL(i,j) = innerprodX(BaseV[j][], BaseV[i][], DiffPEM); 
		DivPRBL(i+Nbases, j) = innerprodX(BaseP[i][], BaseV[j][], DivPPEM);
		PenRBL(i+Nbases, j+Nbases) = innerprodX(BaseP[j][], BaseP[i][], PenPEM);
		ConvLevRBL(i,j) = innerprodX(BaseV[j][], BaseV[i][], ConvLevPEM);
		DTRBL(i,j) = innerprodX(BaseV[j][], BaseV[i][], DTPEM);
		
		if (j<i){
			DiffRBL(j,i) = DiffRBL(i,j);
			DivPRBL(j+Nbases, i) = innerprodX(BaseP[j][], BaseV[i][], DivPPEM);
			PenRBL(j+Nbases, i+Nbases) = PenRBL(i+Nbases, j+Nbases);
			ConvLevRBL(j,i) = innerprodX(BaseV[i][], BaseV[j][], ConvLevPEM);
			DTRBL(j,i) = DTRBL(i,j);
		}	
	}
	contFF++;
}
pause;

mpiAllReduce(DiffRBL, DiffRBG, mpiCommWorld, mpiSUM);
mpiAllReduce(DivPRBL, DivPRBG, mpiCommWorld, mpiSUM);
mpiAllReduce(PenRBL, PenRBG, mpiCommWorld, mpiSUM);
mpiAllReduce(ConvLevRBL, ConvLevRBG, mpiCommWorld, mpiSUM);
mpiAllReduce(DTRBL, DTRBG, mpiCommWorld, mpiSUM);

DiffRB += DiffRBG;
DivPRB += DivPRBG;
PenRB += PenRBL;
ConvLevRB += ConvLevRBL;
DTRB += DTRBL;

// Comienzo el bucle para la construcción de los tensores

// Conveccion

for (int s=0; s<=i; s++){
	real[int, int] CintL(2*Nbases, 2*Nbases), CintG(2*Nbases, 2*Nbases);
	CintL = 0; CintG = 0;
	contFF = 0;
	for (int j=0; j<=i; j++){
		if (mpirank==contFF%mpisize){
			CintL(i,j) = innerprodX(BaseV[j][], BaseV[i][], ConvPEM[s]);
			if(j<i){
				CintL(j,i) = innerprodX(BaseV[i][], BaseV[j][], ConvPEM[s]);
			}
			if (s==i && (j!=i)){
				for (int k=0; k<s; k++){
					CintL(k,j) = innerprodX(BaseV[k][], BaseV[j][], ConvPEM[s]);
				}
			} 
		}
		contFF++;		
	}
	pause;
	mpiAllReduce(CintL, CintG, mpiCommWorld, mpiSUM);
	
	ConvRB[s] += CintG;
}

// Smagorinsky
for (int s=0; s<Mbases; s++){
	real[int, int] SintL(2*Nbases, 2*Nbases), SintG(2*Nbases, 2*Nbases);
	SintL = 0; SintG = 0;
	contFF = 0;
	for (int j=0; j<=i; j++){
		if (mpirank==contFF%mpisize){
			SintL(i,j) = innerprodX(BaseV[j][], BaseV[i][], SmagoPEM[s]);
			if(j<i){
				SintL(j,i) = SintL(i,j);
			}
		}
		contFF++;		
	}
	pause;
	mpiAllReduce(SintL, SintG, mpiCommWorld, mpiSUM);
	
	SmagoRB[s] += SintG;
}

// LPS
for (int s=0; s<Taubases; s++){
	real[int, int] LPSintL(2*Nbases, 2*Nbases), LPSintG(2*Nbases, 2*Nbases);
	LPSintL = 0; LPSintG = 0;
	contFF = 0;
	for (int j=0; j<=i; j++){
		if (mpirank==contFF%mpisize){
			LPSintL(i,j) = innerprodX(BaseP[j][], BaseP[i][], StabPPEM[s]);
			if(j<i){
				LPSintL(j,i) = LPSintL(i,j);
			}
		}
		contFF++;		
	}
	pause;
	mpiAllReduce(LPSintL, LPSintG, mpiCommWorld, mpiSUM);
	
	StabPRB[s] += LPSintG;
}



