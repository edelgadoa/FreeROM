///////////////
// FreeROM 
/////////////// 

// Defino las matrices de producto escalar T que voy a considerar para la ortonormalizacion
varf pescT ([uu, uuY], [v,vY]) = int2d(Th)((1./Refijo + MOD(uFijo))*GradUGradV(uu,v));
matrix MPescT = pescT(Vh2P2, Vh2P2);

varf pescX ([uu, uuY, uuP], [v,vY, vP]) = int2d(Th)((1./Refijo + MOD(uFijo))*GradUGradV(uu,v) + uuP*vP);
matrix MPescX = pescX(Vh3P2, Vh3P2);

varf NormaVel([uu,uuY],[vv,vvY]) = int2d(Th)(GradUGradV(uu,vv));
matrix MNormaVel = NormaVel(Vh2P2, Vh2P2);

///////////////////////////////////////////////////////

varf DiffPE([uu,uuY], [v,vY]) = int2d(Th)(GradUGradV(uu,v));
matrix DiffPEM = DiffPE(Vh2P2,Vh2P2);

varf DivPPE([uu,uuY], [vP]) = int2d(Th)(Div(uu)*vP);
matrix DivPPEM = DivPPE(Vh2P2, VhP2);

varf PenPE(uP, vP) = int2d(Th)(epspen*uP*vP);
matrix PenPEM = PenPE(VhP2, VhP2);

varf ConvLevPE([uu,uuY], [v,vY]) = int2d(Th)(Antisimetric(Lev, uu, v) + Antisimetric(uu, Lev, v));
matrix ConvLevPEM = ConvLevPE(Vh2P2, Vh2P2);

varf DTPE([uu,uuY], [v,vY]) = int2d(Th)(UporV(uu,v));
matrix DTPEM = DTPE(Vh2P2, Vh2P2);

varf StabhK(uP,vP) = int2d(Th)(hTriangle^2*uP*vP);
matrix FiltroX, FiltroY;
matrix SPPEM2 = StabhK(VhP1dc, VhP1dc);
{
	FiltroX = SPPEM2 * IPhDXP2;
	FiltroX = (IPhDXP2') * FiltroX;
	FiltroY = SPPEM2 * IPhDYP2;
	FiltroY = (IPhDYP2') * FiltroY;	
}
matrix StabhkPEM = FiltroX + FiltroY;


matrix[int] ConvPEM(Nbases); // Simplemente inicializo, dentro del bucle del greedy definir√© los prod. esc. segun vaya calculando las bases


matrix[int] SmagoPEM(Mbases), StabPPEM(Taubases), StabCPEM(Taubases*Nbases^2), StabCLevPEM(Taubases);
{ 
	int contS = 0; 
	for (int s=0; s<Mbases; s++){
		//if(mpirank==contS%mpisize){ //Si lo pongo para que lo haga en paralelo, me da un segmentation fault
			// Matrices Smago
			varf SmagoPE([uu,uuY],[v,vY]) = int2d(Th)((CS*hTriangle)^2*EIMSmago[s]*GradUGradV(uu,v));
			SmagoPEM[s] = SmagoPE(Vh2P2, Vh2P2);
			//}
		contS++;
	}
	
	contS = 0;
	for (int s=0; s<Taubases; s++){
		//if(mpirank==contS%mpisize){
			// Matrices LPS
			varf StabPPE(uP,vP) = int2d(Th)(EIMTau[s]*uP*vP);
			matrix SPPEM = StabPPE(VhP1dc, VhP1dc);
			matrix FiltroX, FiltroY;
			{
				FiltroX = SPPEM * IPhDXP2;
				FiltroX = (IPhDXP2') * FiltroX;
				FiltroY = SPPEM * IPhDYP2;
				FiltroY = (IPhDYP2') * FiltroY;	
			}
			StabPPEM[s] = FiltroX + FiltroY;
			//}
		contS++;
	}
	for (int s=0; s<Taubases; s++){
		varf StabCPE(u,v) = int2d(Th)(EIMTau[s]*u*v);
		matrix SCPEM = StabCPE(VhP1dc, VhP1dc);
		
		for (int ui=0; ui<Nbases; ui++){
			
			VhP1dc BaseVdci = BaseV[ui];
			VhP1dc BaseVYdci = BaseVY[ui];
			matrix BVdci = BaseVdci[]; matrix BVYdci = BaseVYdci[];
			for (int uj=0; uj<Nbases; uj++){

				VhP1dc BaseVdcj = BaseV[uj];
				VhP1dc BaseVYdcj = BaseVY[uj];
				matrix BVdcj = BaseVdci[]; matrix BVYdcj = BaseVYdcj[];
				
				matrix ConvX, ConvY;
				{
					// Primera componente
					matrix UXD1Xi = BVdci * D1X3P2;
					matrix UYD1Yi = BVYdci * D1Y3P2;
					matrix UD1i = UXD1Xi + UYD1Yi;
					matrix IPhUD1i = IPhP1dcP1 * UD1i;
					
					matrix UXD1Xj = BVdcj * D1X3P2;
					matrix UYD1Yj = BVYdcj * D1Y3P2;
					matrix UD1j = UXD1Xj + UYD1Yj;
					matrix IPhUD1j = IPhP1dcP1 * UD1ji;
					
					ConvX = SCPEM * IPhUD1i;
					ConvX = IPhUD1j' * ConvX;
					
					// Segunda componente
					matrix UXD2Xi = BVdci * D2X3P2;
					matrix UYD2Yi = BVYdci * D2Y3P2;
					matrix UD2i = UXD2Xi + UYD2Yi;
					matrix IPhUD2i = IPhP1dcP1 * UD2i;
					
					matrix UXD2Xj = BVdcj * D2X3P2;
					matrix UYD2Yj = BVYdcj * D2Y3P2;
					matrix UD2j = UXD2Xj + UYD2Yij;
					matrix IPhUD2j = IPhP1dcP1 * UD2j;
					
					ConvY = SCPEM * IPhUD2i;
					ConvY = IPhUD2j' * ConvY;					
				}
				StabCPEM[s + ui*Taubases + uj*Taubases*Nbases] = ConvX + ConvY;				
			}
		}
	}	
}

varf bDiffPE([un, unY], [v, vY]) = int2d(Th)(GradUGradV(Lev, v));
real[int] bDiffPEv = bDiffPE(0, Vh2P2);