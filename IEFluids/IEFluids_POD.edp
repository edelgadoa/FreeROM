///////////////
// FreeROM 
///////////////
verbosity = 0;
 
load "msh3"
load "gmsh"
load "iovtk"
load "lapack" // Eigenvalue problem solving
include "IO.idp" // Para leer y guardar 

// Calculo en paralelo
macro dimension()3 //EOM
include "macro_ddm.idp";
load "PETSc";



// Defino algun macro que necesitare
macro GradUGradV(U,V) (dx(U)*dx(V)     + dy(U)*dy(V)     + dz(U)*dz(V) 
					 + dx(U#Y)*dx(V#Y) + dy(U#Y)*dy(V#Y) + dz(U#Y)*dz(V#Y)
					 + dx(U#Z)*dx(V#Z) + dy(U#Z)*dy(V#Z) + dz(U#Z)*dz(V#Z)) //EOM

int[int] fforder=[1,1,1,1];
// Cargamos las funciones para pasar la numeracion de IEfluids a FreeFem
include "IE2FF.idp"

// Cargo las funciones para el calculo de productos escalares y normas
include "Normas_3d.idp"

mesh3 Th = readmesh3("IEfluids.mesh"); 
mesh3 ThL = Th;

// Preparo el paralelo
Mat MatAVh3P1;
Mat MatAVhP1;
int[int] mapVh3P1, mapVhP1;

int[int] myN2o;
macro ThLN2O() myN2o //EOM
buildDmesh(ThL);

fespace VhP1(Th, P1);
fespace Vh3P1(Th, [P1,P1,P1]);

fespace VhP1L(ThL, P1);
fespace Vh3P1L(ThL, [P1,P1,P1]);


mapVh3P1 = restrict(Vh3P1L,Vh3P1,myN2o);
mapVhP1 = restrict(VhP1L,VhP1,myN2o);

{
	macro def(i) [i, iY, iZ] //
	macro init(i) [i, i, i] // EOM
	createMat(ThL, MatAVh3P1, [P1, P1, P1]);
}
{
	createMat(ThL, MatAVhP1, P1);
}


varf NormH1([u, uY, uZ],[v, vY, vZ]) = int3d(ThL)(GradUGradV(u,v));
matrix H1PEM = NormH1(Vh3P1L, Vh3P1L);
MatAVh3P1 = H1PEM;

varf NormL2(p,q) = int3d(ThL)(p*q);
matrix L2PEM = NormL2(VhP1L, VhP1L);
MatAVhP1 = L2PEM;


int ReSnap = 20; // numero de Snapshots de Reynolds
int TimeSnap = 6; // numero de Snapshots en tiempo por cada Reynolds
int Nsnap = ReSnap*TimeSnap;

// Variables donde guardo los snapshots que cargo
Vh3P1[int] [Vh,VhY,VhZ](Nsnap);
VhP1[int] Ph(Nsnap);

Vh3P1L[int] [VhL,VhLY,VhLZ](Nsnap);
VhP1L[int] PhL(Nsnap);

// Comienzo bucle de lectura de snapshots
if (mpirank==0 || mpirank==1){ 		//lo hago en "paralelo", un procesador para vel y otro para pres
	for (int NRe=1; NRe<=ReSnap; NRe++){
		for (int NTemp=1; NTemp<=TimeSnap; NTemp++){
			int i = (NTemp-1) + (NRe-1)*TimeSnap;
			if(mpirank==0){ 
				cout<<"V_"+NRe+"_meanfile"+NTemp<<endl;
				readvector("Snapshots/V_"+NRe+"_meanfile"+NTemp+".txt", real, Vel, 0);
				Vh[i][] = Vel;
				[VhL[i], VhLY[i], VhLZ[i]] = [Vh[i], VhY[i], VhZ[i]];
			}
			if(mpirank==1){
				cout<<"P_"+NRe+"_meanfile"+NTemp<<endl;
				readvector("Snapshots/P_"+NRe+"_meanfile"+NTemp+".txt", real, Pres, 0);
				Ph[i][] = Pres; 
				PhL[i] = Ph[i];
			}
		}
	}
}
mpiBarrier(mpiCommWorld);

// Creamos las matrices de Correlacion
real [int,int] CV(Nsnap, Nsnap), CP(Nsnap, Nsnap);

for (int i=0; i<Nsnap; i++){
	real[int] Vhi, Phi;
	ChangeNumbering(MatAVh3P1, VhL[i][], Vhi);
	ChangeNumbering(MatAVhP1, PhL[i][], Phi);
	for (int j=0; j<=i; j++){
		 real[int] Vhj, Phj;
		ChangeNumbering(MatAVh3P1, VhL[j][], Vhj);
		ChangeNumbering(MatAVhP1, PhL[j][], Phj);
		CV(i,j) = (1./Nsnap)*innerprodX(Vhi, Vhj, MatAVh3P1);
		CP(i,j) = (1./Nsnap)*innerprodX(Phi, Phj, MatAVhP1);
		if(j<i){
			CV(j,i) = CV(i,j); //Matriz simetrica 
			CP(j,i) = CP(i,j);
		}
	}
}

// Calculo los eigenvalues y eigenvectors 
real[int] SU(Nsnap), SP(Nsnap);
real[int,int] UU(Nsnap, Nsnap), UP(Nsnap, Nsnap), VTU(Nsnap, Nsnap), VTP(Nsnap, Nsnap);

// Calculo el SVD --> C = U*S*VT 
dgesdd(CV,UU,SU,VTU);
dgesdd(CP,UP,SP,VTP);

// Guardo el valor de los autovalores
write("EigenV.txt", SU, 0, 0);
write("EigenP.txt", SP, 0, 0);
