// Online

// Cargamos librerias
load "iovtk" 
load "lapack"
load "PETSc"

// Cargamos macros, funciones i/o
include "../Auxiliary/IO.idp"
include "../Auxiliary/Macros_2D.idp"
// include "../Auxiliary/macro_ddm.idp"
include "../Auxiliary/search.idp"

// Definimos los parametros a usar
include "../Auxiliary/Parametros_2D.idp"

// Creamos la Malla
include "../Auxiliary/Malla.idp"

// Definimos los espacios de EF
include "../FOM/FE_Spaces_NoStab_VP_2D.idp"

// Carga de bases
readmatrix("../Offline/Bases/BaseV_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,BaseV,0);
int NbasesV = BaseV.m; // Dimension reducido
readvector("../Offline/Bases/MediaV_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,MediaV,0);
Vh2P2 [uM,uMY];
uM[] = MediaV;

// Condición inicial
write("Output.txt","Computing initial conditions...",1,1);

TFR = TF;
TF = TFR-period;

Vh3P2 [SnapX,SnapY,SnapP];
readvector("../Snapshots/Vx_" + Reynolds + "_t_" +TF+ ".txt", real, SolX, 0);
readvector("../Snapshots/Vy_" + Reynolds + "_t_" +TF+ ".txt", real, SolY, 0);
SnapX[] = SolX; SnapY[] = SolY;

Vh2P2 [uEFP,uEFPY];
[uEFP,uEFPY] = [SnapX, SnapY];
[uEFP,uEFPY] = [uEFP-uM, uEFPY-uMY];

readvector("../Snapshots/Vx_" + Reynolds + "_t_" +(TF-dt)+ ".txt", real, SolPX, 0);
readvector("../Snapshots/Vy_" + Reynolds + "_t_" +(TF-dt)+ ".txt", real, SolPY, 0);
SnapX[] = SolPX; SnapY[] = SolPY;

Vh2P2 [uEFP1,uEFP1Y];
[uEFP1,uEFP1Y] = [SnapX, SnapY];
[uEFP1,uEFP1Y] = [uEFP1-uM, uEFP1Y-uMY];

real[int] uR(NbasesV), uRP(NbasesV), uRP1(NbasesV);
for(int i=0;i<NbasesV;i++){
    Vh2P2 [V,VY];
    V[]=BaseV(:,i); 
    uRP(i) = int2d(Th)(V*uEFP+VY*uEFPY);
    uRP1(i) = int2d(Th)(V*uEFP1+VY*uEFP1Y);
}
write("Output.txt","Initial conditions OK",1,1);

// Matrices reducidas
write("Output.txt","Reading offline matrices...",1,1);

readmatrix("../Offline/ElementosOffline/MMasaR_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,MMasaR,0);
readmatrix("../Offline/ElementosOffline/MGradR_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,MGradR,0);
readmatrix("../Offline/ElementosOffline/MConvMGR_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,MConvMGR,0);
readmatrix("../Offline/ElementosOffline/MConvGMR_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,MConvGMR,0);

readvector("../Offline/ElementosOffline/bMasaR_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,bMasaR,0);
readvector("../Offline/ElementosOffline/bGradR_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,bGradR,0);
readvector("../Offline/ElementosOffline/bConvR_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,bConvR,0);

readtensor("../Offline/ElementosOffline/MsConvR_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,MsConvR,0)

// Elementos fijos
real[int,int] MFijaR(NbasesV,NbasesV);
MFijaR = a0*dtt*MMasaR;
MFijaR += nu*MGradR;
MFijaR += MConvMGR;

real[int] bFijoR(NbasesV);
bFijoR = nu*bGradR;
bFijoR += bConvR;
write("Output.txt","Reduced Matrices Ok.",1,1);

// RBF
write("Output.txt","Reading RBF elements ...",1,1);
readmatrix("../Offline/RBF/PesosVTau_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,PesosVTau,0);
readmatrix("../Offline/RBF/PesosVDTau_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,PesosVDTau,0);
int NbasesVTau = PesosVTau.m;
int NbasesVDTau = PesosVDTau.m;


readmatrix("../Offline/RBF/BaseVTau_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,BaseVTau,0);
readmatrix("../Offline/RBF/BaseVDTau_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,BaseVDTau,0);
readtensor("../Offline/ElementosOffline/MsVDTauR_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,MsVDTauR,0)
readtensor("../Offline/ElementosOffline/MsVtauR_"+Reynolds+"_PODtol_"+(-log10(epsPOD))+".txt",real,MsVTauR,0)


readmatrix("../Offline/RBF/DataVDTau_" + Reynolds + ".txt",real,SnapVDTau,0);

// Definicion de la funcion Gaussiana
func real gauss(real r){
 	if(1-r/(5*dt)>=0){
	    return (1-r/(5*dt));
    }else{
	    return 	 0;
    }
}

nit = (TFR-TF)/dt+1;
real[int] X(nit); // Vector de espacio de parametros
for(int i=0; i<nit; i++){
    X(i)=TF+i*dt;
}

real[int,int] gaussRBF(nit,nit);
real dist;
for(int i=0; i<nit; i++){
    for(int j=i; j<nit; j++){
        dist = abs(X(i)-X(j));
        gaussRBF(i,j)=gauss(dist);
        gaussRBF(j,i)=gaussRBF(i,j);
    }
}

real[int] VDTau(BaseVDTau.n);
VDTau=0.;
int nS = 0;
real[int] d = gaussRBF(nS,:);
cout << d << endl;
// real[int] uRBF = PesosVDTau'*d;
real uRBF;
for(int i=0; i<NbasesVDTau; i++){
    uRBF = d(i)*PesosVDTau(nS,i);
    VDTau += uRBF*BaseVDTau(:,i);
}
VhP2 uu;
uu[] = VDTau;
plot(uu);
uu[] = SnapVDTau(:,nS);
plot(uu);

write("Output.txt","RBF Ok.",1,1);

// Bucle temporal 
real[int,int] MVarR(NbasesV,NbasesV);
real[int] bVarR(NbasesV);
for(real ti=TF+dt;ti<=TFR+epsEF;ti+=dt){
    
	write("Output.txt","t = " + ti,0,1);

    // Calculamos los coeficientes de las RBF
    int nn = (ti-TF)/dt-1;
    real[int] d = X(:,nn); // Distancia paramétrica
    real[int] uVTauRBF = PesosVTau*d;
    real[int] uVDTauRBF = PesosVDTau*d;

    // Calculo de los elementos variables
    real[int,int] MVarConvPR(NbasesV,NbasesV); MVarConvPR = 0.;
    real[int,int] MVarConvP1R(NbasesV,NbasesV); MVarConvP1R = 0.;
    real[int,int] MVarVTauPR(NbasesV,NbasesV); MVarVTauPR = 0.;
    real[int,int] MVarVTauP1R(NbasesV,NbasesV); MVarVTauP1R = 0.;
    real[int,int] MVarVDTauPR(NbasesV,NbasesV); MVarVDTauPR = 0.;
    real[int,int] MVarVDTauP1R(NbasesV,NbasesV); MVarVDTauP1R = 0.;
    for(int i=0; i<NbasesV; i++){
        MVarConvPR += uRP(i)*MsConvR[i];
        MVarConvP1R += uRP1(i)*MsConvR[i];

        for(int j=0; j<NbasesV; j++){
            real uRPj = uRP(j);
            real uRP1j = uRP1(j);
            real[int,int] Maux(NbasesV,NbasesV);
            for(int k=0; k<NbasesVDTau; k++){
                Maux = uVDTauRBF(k)*MsVDTauR[j*NbasesVDTau+k];
                MVarVDTauPR += uRPj*Maux;
                MVarVDTauP1R += uRP1j*Maux;
            }
            for(int k=0; k<NbasesVTau; k++){
                Maux = uVTauRBF(k)*MsVTauR[j*NbasesVTau+k];
                MVarVTauPR += uRPj*Maux;
                MVarVTauP1R += uRP1j*Maux;
            }
        }
    }
    MVarR = b0*MVarConvPR;
    //MVarR -= b0*MVarVDTauPR;
    //MVarR -= b0*MVarVTauPR;
    MVarR += b1*MVarConvP1R;
    //MVarR -= b1*MVarVDTauP1R;
    //MVarR -= b1*MVarVTauP1R;

    real[int] aux=MMasaR*uRP;
    bVarR = a1*dtt*aux;
    aux=MMasaR*uRP1;
    bVarR += a2*dtt*aux;
    aux = MConvGMR*uRP;
    bVarR += b0*aux;
    aux = MConvGMR*uRP1;
    bVarR += b1*aux;

    // Sistema lineal
    matrix MFinalR;
    real[int] bFinalR(NbasesV);

    MFinalR = MFijaR;
    MFinalR += MVarR;

    bFinalR = -bFijoR;
    bFinalR -= bVarR;

    // Resolucion
	set(MFinalR, solver=sparsesolver);
	uR=MFinalR^-1*bFinalR;

    // Actualizacion
    uRP1 = uRP;
    uRP = uR;

    // Representacion
    Vh2P2 [uEF,uEFY];
    uEF[] = BaseV*uR;
    [uEF,uEFY] = [uEF+uM,uEFY+uMY];
    VhP2 uEFmod;
    uEFmod = uEF^2+uEFY^2;
    plot(uEFmod,fill=1,value=1,cmm = "t = "+ti);

    write("Datos/VxEstabR0_" + Reynolds + "_t_" +ti+ ".txt", uEF[], 0, 0);
    write("Datos/VyEstabR0_" + Reynolds + "_t_" +ti+ ".txt", uEFY[], 0, 0);
}

write("Output.txt","Done.",0,1);
